---
phase: 05-knowledge-surfacing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/references/knowledge-surfacing.md
  - .claude/agents/knowledge-store.md
  - get-shit-done/references/planning-config.md
autonomous: true

must_haves:
  truths:
    - "A single reference document defines how all agents query, rank, cite, and propagate knowledge"
    - "The knowledge store schema supports depends_on for freshness checking"
    - "Debug mode is configurable via knowledge_debug in planning config"
  artifacts:
    - path: "get-shit-done/references/knowledge-surfacing.md"
      provides: "Central knowledge surfacing specification"
      contains: "Query Mechanics"
      min_lines: 100
    - path: ".claude/agents/knowledge-store.md"
      provides: "depends_on field in Common Base Schema"
      contains: "depends_on"
    - path: "get-shit-done/references/planning-config.md"
      provides: "knowledge_debug config documentation"
      contains: "knowledge_debug"
  key_links:
    - from: "get-shit-done/references/knowledge-surfacing.md"
      to: "~/.claude/gsd-knowledge/index.md"
      via: "query mechanics instructions"
      pattern: "gsd-knowledge/index\\.md"
    - from: "get-shit-done/references/knowledge-surfacing.md"
      to: ".claude/agents/knowledge-store.md"
      via: "depends_on freshness model references KB schema"
      pattern: "depends_on"
---

<objective>
Create the knowledge surfacing reference specification and update the knowledge store schema with depends_on freshness support and knowledge_debug config.

Purpose: This is the foundation document all four agents will reference via @ syntax. It centralizes query mechanics, citation format, token budgets, freshness checking, spike deduplication, progressive disclosure, cross-project surfacing, and debug mode into one authoritative reference. Without this, each agent section would need to duplicate the full specification.

Output: One new reference document (knowledge-surfacing.md) and two additive updates to existing specs (knowledge-store.md, planning-config.md).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-knowledge-surfacing/05-CONTEXT.md
@.planning/phases/05-knowledge-surfacing/05-RESEARCH.md
@.claude/agents/knowledge-store.md
@get-shit-done/references/planning-config.md
@get-shit-done/references/spike-integration.md
@get-shit-done/references/reflection-patterns.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create knowledge-surfacing.md reference specification</name>
  <files>get-shit-done/references/knowledge-surfacing.md</files>
  <action>
Create `get-shit-done/references/knowledge-surfacing.md` -- the central reference document for knowledge surfacing. This document is consumed by all four agent types via `@get-shit-done/references/knowledge-surfacing.md` references in their `<knowledge_surfacing>` sections.

Structure the document with these sections (derived from CONTEXT.md decisions and RESEARCH.md patterns):

**Section 1: Overview**
- Purpose: make passive knowledge active during agent workflows
- Scope: lessons (from reflection) and spike decisions only -- NOT raw signals
- Mechanism: agent-initiated (pull-based) querying via Read/Grep on KB paths
- Fork compatibility: agents check if this file exists before applying

**Section 2: Query Mechanics**
- Step-by-step: Read `~/.claude/gsd-knowledge/index.md` first
- Scan Lessons table and Spikes table for tag/project overlap
- For matching entries (max 5), read full entry files
- Cross-project: query WITHOUT project filter to get all entries (satisfies SURF-04)
- Include the index format example (Lessons table with ID, Project, Category, Tags, Date, Status columns)

**Section 3: Relevance Matching**
- Hybrid: index file + tags
- Tags: hierarchical freeform (e.g., `auth/jwt`, `database/prisma/migrations`)
- Stack awareness: include relevant technologies in query context
- Partial matches: include with lower rank
- Ranking: agent LLM judgment (not brittle tag-counting)
- Conflicting entries: surface both, flag the conflict

**Section 4: Freshness Checking (depends_on)**
- Primary mechanism: check `depends_on` frontmatter flags against current codebase
- `depends_on` is a documentation field -- agents READ it and use judgment
- Examples: `"prisma >= 4.0"`, `"src/lib/auth.ts exists"`, `"NOT monorepo"`
- If dependency changed: surface with caveat noting the change
- Temporal decay FALLBACK (when depends_on absent or unverifiable):
  - < 30 days: full confidence
  - 30-90 days: slight reduction
  - > 90 days: note age, lower confidence
  - Never exclude solely based on age
- Failed phase knowledge: include with flag

**Section 5: Token Budget and Truncation**
- Soft cap: ~500 tokens of surfaced knowledge (agents can exceed if genuinely critical)
- Executor exception: ~200 tokens (deviation context only)
- Truncation strategy: trim to one-liner summaries first (preserves breadth), then drop lowest relevance
- Token estimation: ~1 token per 4 characters (rough, adequate for soft cap)

**Section 6: Citation Format and Output**
- Inline citations: "A prior lesson [les-2026-01-15-validate-tokens] found that..." (grepable + readable)
- Summary section at end of agent output: "## Knowledge Applied"
- Summary section template with: KB entries consulted count, Applied entries with citations, Dismissed entries (only if contradicted chosen approach), Spikes avoided count
- No results: "Checked knowledge base, no relevant entries found."
- Verbosity: summary + file path link to full entry

**Section 7: Spike Deduplication (SPKE-08)**
- Part of mandatory initial KB query (no separate step)
- Check Spikes table in index.md for tag/hypothesis overlap
- Matching criteria: same technology, same constraints, same scale, no significant codebase changes
- If applicable: adopt finding, cite it, note as "spike avoided"
- Partial match: adopt answered portion, note the gap
- Confidence: surface spike confidence level (confirmed/rejected/inconclusive)
- Composite answers: synthesize from multiple spikes, flag as composite
- Incidental answers: adopt with lower confidence
- End-of-research stat: "Spikes avoided: N (spk-xxx, spk-yyy)"

**Section 8: Agent-Specific Behavior**
Table summarizing per-agent query behavior:
| Agent | Trigger | Query Type | Priority | Budget |
| researcher | Mandatory at start + on error/direction change | Full KB (lessons + spikes) | Spike decisions first | ~500 tokens |
| planner | Optional, at discretion | Lessons only | Strategic lessons | ~500 tokens |
| debugger | Optional, at discretion | Lessons + spikes related to error | Both equally | ~500 tokens |
| executor | ONLY on deviation Rules 1-3 | Lessons related to error | Error-relevant | ~200 tokens |

**Section 9: Knowledge Chain (Downstream Propagation)**
- Upstream agents write findings to existing artifacts (RESEARCH.md, PLAN.md)
- Downstream agents see upstream's findings naturally (no redundant lookups)
- Downstream agents CAN query for additional knowledge relevant to their specific concerns
- Propagation form: upstream's interpretation (conclusion, not raw entry)

**Section 10: Progressive Disclosure**
- Tier 1: index.md summaries (always read first)
- Tier 2: full entry files (read on-demand for top matches)
- No interactive menu for v1 -- agent reads index, picks top matches, reads full entries
- Knowledge store already has this layering built in

**Section 11: Debug Mode**
- Flag: `knowledge_debug` in `.planning/config.json` (default: false)
- When enabled: log ALL KB entries considered, not just applied ones
- When disabled: only log applied entries in Knowledge Applied section
- Checking: `cat .planning/config.json 2>/dev/null | grep -o '"knowledge_debug"[[:space:]]*:[[:space:]]*[^,}]*' | grep -o 'true\|false' || echo "false"`

Follow the format conventions established by other reference docs in the project (spike-execution.md, signal-detection.md, reflection-patterns.md). Use markdown headers, tables, and code blocks. Include the fork detection pattern at the top (agents check if this file exists).

Do NOT create a new agent file. The reference document is consumed by existing agents via their `<knowledge_surfacing>` sections (created in plans 02 and 03).
  </action>
  <verify>
Verify the file exists and contains all required sections:
```bash
test -f get-shit-done/references/knowledge-surfacing.md && echo "EXISTS" || echo "MISSING"
grep -c "## " get-shit-done/references/knowledge-surfacing.md  # Should show 10+ section headers
grep "depends_on" get-shit-done/references/knowledge-surfacing.md | head -3  # Freshness model present
grep "500 token" get-shit-done/references/knowledge-surfacing.md  # Token budget present
grep "Spikes avoided" get-shit-done/references/knowledge-surfacing.md  # Spike dedup stat present
grep "knowledge_debug" get-shit-done/references/knowledge-surfacing.md  # Debug mode present
grep "SURF-04\|cross-project\|Cross-project" get-shit-done/references/knowledge-surfacing.md  # Cross-project present
grep "gsd-knowledge/index.md" get-shit-done/references/knowledge-surfacing.md  # Query mechanics present
```
  </verify>
  <done>
knowledge-surfacing.md exists in get-shit-done/references/ with all 11 sections covering: overview, query mechanics, relevance matching, freshness checking, token budget, citation format, spike deduplication, agent-specific behavior, knowledge chain, progressive disclosure, and debug mode. The document references index.md as the query entry point, specifies ~500 token soft cap, defines the depends_on freshness model with temporal decay fallback, and includes the fork detection pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update knowledge-store.md and planning-config.md with new fields</name>
  <files>.claude/agents/knowledge-store.md, get-shit-done/references/planning-config.md</files>
  <action>
**knowledge-store.md update (additive only):**

Add `depends_on` as a new optional field in Section 3 (Common Base Schema). Insert it in the "Optional tracking fields" table area (after `last_retrieved`, before Section 4). Add a new subsection:

```markdown
**Optional freshness fields:**

| Field | Type | Description |
|-------|------|-------------|
| `depends_on` | array | Conditions that could invalidate this entry. Each element is a human-readable string describing a dependency (e.g., `"prisma >= 4.0"`, `"src/lib/auth.ts exists"`, `"NOT monorepo"`). Agents read these and use judgment to assess whether the entry is still valid. |

The `depends_on` field supports the knowledge surfacing system's freshness model. When agents retrieve an entry, they check `depends_on` conditions against the current codebase. If conditions no longer hold, the entry is surfaced with a staleness caveat. If `depends_on` is absent, agents fall back to temporal decay heuristics.
```

Also add `depends_on` to the YAML example in the common base schema block (as an optional commented-out field):
```yaml
# depends_on: ["prisma >= 4.0", "src/lib/auth.ts exists"]
```

Do NOT modify any existing fields or sections. This is purely additive.

**planning-config.md update (additive only):**

Add a new `<knowledge_surfacing_config>` section at the end of the file (before the closing `</planning_config>` tag). Include:

```markdown
<knowledge_surfacing_config>

**Knowledge surfacing configuration:**

| Option | Default | Description |
|--------|---------|-------------|
| `knowledge_debug` | `false` | When true, agents log all KB entries considered during knowledge surfacing (not just applied entries). Useful for diagnosing why entries were or weren't surfaced. |

**Checking the config:**

```bash
KNOWLEDGE_DEBUG=$(cat .planning/config.json 2>/dev/null | grep -o '"knowledge_debug"[[:space:]]*:[[:space:]]*[^,}]*' | grep -o 'true\|false' || echo "false")
```

**When `knowledge_debug: true`:**
- Agents include a "## KB Debug Log" section listing all entries they read from index.md
- Each entry shows: ID, tags, relevance assessment (why included or excluded), freshness status
- This section is in addition to the standard "## Knowledge Applied" section

**When `knowledge_debug: false` (default):**
- Standard behavior: only "## Knowledge Applied" section with applied/dismissed entries
- No debug logging overhead

</knowledge_surfacing_config>
```

Also add `knowledge_debug` to the config_schema JSON example at the top of the file and to the options table.
  </action>
  <verify>
```bash
# knowledge-store.md has depends_on
grep "depends_on" .claude/agents/knowledge-store.md | head -3
# planning-config.md has knowledge_debug
grep "knowledge_debug" get-shit-done/references/planning-config.md | head -3
# planning-config.md has the config section
grep "knowledge_surfacing_config" get-shit-done/references/planning-config.md
```
  </verify>
  <done>
knowledge-store.md Common Base Schema (Section 3) includes `depends_on` as an optional freshness field with description and usage guidance. planning-config.md includes `knowledge_debug` field in the config schema, options table, and a new `<knowledge_surfacing_config>` section documenting behavior for both true/false states.
  </done>
</task>

</tasks>

<verification>
1. `get-shit-done/references/knowledge-surfacing.md` exists with 100+ lines covering all 11 specification sections
2. `.claude/agents/knowledge-store.md` has `depends_on` documented in Section 3 without modifying existing fields
3. `get-shit-done/references/planning-config.md` has `knowledge_debug` in config schema and behavior documentation
4. No upstream agent files modified (agents/ directory untouched)
5. No new runtime dependencies introduced
</verification>

<success_criteria>
- The knowledge surfacing reference document is complete and can be consumed by agent `<knowledge_surfacing>` sections via @ syntax
- The depends_on field is documented in the knowledge store schema as an optional freshness field
- The knowledge_debug config option is documented with checking pattern and behavior for both states
- All changes are additive (no existing content modified or removed)
</success_criteria>

<output>
After completion, create `.planning/phases/05-knowledge-surfacing/05-01-SUMMARY.md`
</output>
