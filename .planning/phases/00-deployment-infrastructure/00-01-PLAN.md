---
phase: 00-deployment-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - vitest.config.js
  - tests/helpers/tmpdir.js
  - tests/helpers/setup.js
autonomous: true

must_haves:
  truths:
    - "npm test runs without error"
    - "Vitest discovers and can execute test files"
    - "Temp directory fixture creates isolated directories per test"
    - "Package is named get-shit-done-reflect-cc"
    - "npx get-shit-done-reflect-cc installs files to ~/.claude/ correctly"
  artifacts:
    - path: "package.json"
      provides: "Fork package identity and test scripts"
      contains: "get-shit-done-reflect-cc"
    - path: "vitest.config.js"
      provides: "Test framework configuration"
      contains: "defineConfig"
    - path: "tests/helpers/tmpdir.js"
      provides: "Temp directory test fixture"
      exports: ["tmpdirTest"]
    - path: "tests/helpers/setup.js"
      provides: "Global test setup"
    - path: "bin/install.js"
      provides: "Installation script (existing from upstream, verified for fork)"
      contains: "install"
  key_links:
    - from: "package.json"
      to: "vitest.config.js"
      via: "npm test script"
      pattern: "vitest"
    - from: "vitest.config.js"
      to: "tests/helpers/setup.js"
      via: "setupFiles config"
      pattern: "setupFiles.*setup\\.js"
    - from: "package.json"
      to: "bin/install.js"
      via: "bin entry point"
      pattern: "bin.*install"
---

<objective>
Set up the test infrastructure foundation for the GSD Reflect fork. This establishes the package identity, installs Vitest, creates reusable test helpers, and verifies the existing install script works with the renamed package.

Purpose: Enable all subsequent testing work by providing the framework, configuration, and helper fixtures needed to write isolated, deterministic tests. Also ensures the fork is installable via npx.
Output: Configured Vitest with temp directory fixture pattern, verified install script for fork.
</objective>

<execution_context>
@/Users/rookslog/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rookslog/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/00-deployment-infrastructure/00-CONTEXT.md
@.planning/phases/00-deployment-infrastructure/00-RESEARCH.md
@package.json
@bin/install.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update package.json for fork identity</name>
  <files>package.json</files>
  <action>
Update package.json to establish the fork's identity:

1. Change `name` from "get-shit-done-cc" to "get-shit-done-reflect-cc"
2. Change `bin` key from "get-shit-done-cc" to "get-shit-done-reflect-cc"
3. Update `repository.url` to the fork's GitHub URL (keep as placeholder if URL unknown)
4. Update `homepage` and `bugs.url` similarly
5. Add test scripts:
   - "test": "vitest run"
   - "test:watch": "vitest"
   - "test:coverage": "vitest run --coverage"
6. Add vitest and @vitest/coverage-v8 to devDependencies:
   - "vitest": "^3.0.0"
   - "@vitest/coverage-v8": "^3.0.0"

Keep all other fields unchanged (version, description, files, keywords, etc.).

NOTE: The existing bin/install.js from upstream GSD works correctly with the fork - it reads the package name from package.json dynamically, so renaming the package is sufficient. No changes to install.js needed.
  </action>
  <verify>
Run `cat package.json | grep -E "(name|test|vitest)"` and verify:
- name is "get-shit-done-reflect-cc"
- test scripts exist
- vitest is in devDependencies
  </verify>
  <done>Package.json identifies the fork and includes test scripts.</done>
</task>

<task type="auto">
  <name>Task 2: Verify install script works with fork</name>
  <files>bin/install.js (read-only verification)</files>
  <action>
The install script (bin/install.js) already exists from upstream GSD. Verify it works correctly with the renamed fork package:

1. Read bin/install.js and confirm it:
   - Reads package name from package.json dynamically (const pkg = require('../package.json'))
   - Uses pkg.name or pkg.version where needed
   - Does NOT have hardcoded "get-shit-done-cc" that would break with the fork name

2. Run a local install test:
   - Run `node bin/install.js --help` to verify the script executes
   - Check the banner output contains the correct version from package.json

3. Document findings:
   - If script works as-is: Note in summary that no changes needed
   - If hardcoded strings found: Create follow-up task (should not happen based on upstream code review)

The install script uses the pattern:
```javascript
const pkg = require('../package.json');
// Uses pkg.version for display
```

This means changing package.json name is sufficient for the fork identity.
  </action>
  <verify>
Run these checks:
1. `grep -n "get-shit-done-cc" bin/install.js` - should return empty (no hardcoded package name)
2. `node bin/install.js --help` - should display help without errors
3. `grep "require.*package.json" bin/install.js` - confirms dynamic package loading
  </verify>
  <done>Install script verified to work with fork package name, no modifications needed.</done>
</task>

<task type="auto">
  <name>Task 3: Create Vitest configuration</name>
  <files>vitest.config.js</files>
  <action>
Create vitest.config.js at project root with configuration for Node.js CLI testing:

```javascript
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    environment: 'node',
    globals: false,
    testTimeout: 30000,
    hookTimeout: 30000,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'lcov'],
      exclude: ['**/node_modules/**', '**/tests/**', '**/hooks/dist/**']
    },
    include: ['tests/**/*.test.js'],
    setupFiles: ['./tests/helpers/setup.js']
  }
})
```

Key settings:
- environment: 'node' - Testing CLI tools, not browser code
- globals: false - Explicit imports for clarity
- testTimeout: 30000 - Allow time for file operations
- coverage excludes tests and dist files
- include pattern finds all test files in tests/
- setupFiles runs global setup before tests
  </action>
  <verify>
Run `cat vitest.config.js` and verify it contains:
- defineConfig import
- environment: 'node'
- setupFiles pointing to tests/helpers/setup.js
  </verify>
  <done>Vitest is configured for Node.js CLI testing with coverage.</done>
</task>

<task type="auto">
  <name>Task 4: Create test helpers</name>
  <files>tests/helpers/tmpdir.js, tests/helpers/setup.js</files>
  <action>
Create the tests/helpers/ directory and two helper files:

**tests/helpers/tmpdir.js** - Temp directory test fixture:
```javascript
// Temp directory fixture for test isolation
// Source: https://sdorra.dev/posts/2024-02-12-vitest-tmpdir
import { test } from 'vitest'
import os from 'node:os'
import fs from 'node:fs/promises'
import path from 'node:path'

/**
 * Extended test that provides an isolated temp directory
 * Usage: tmpdirTest('test name', async ({ tmpdir }) => { ... })
 * The directory is automatically cleaned up after the test
 */
export const tmpdirTest = test.extend({
  tmpdir: async ({}, use) => {
    const directory = await fs.mkdtemp(path.join(os.tmpdir(), 'gsd-test-'))
    await use(directory)
    await fs.rm(directory, { recursive: true })
  }
})

/**
 * Create a mock home directory structure for testing install
 * @param {string} tmpdir - Base temp directory
 * @returns {Promise<string>} Path to mock home directory
 */
export async function createMockHome(tmpdir) {
  const mockHome = path.join(tmpdir, 'home')
  await fs.mkdir(path.join(mockHome, '.claude'), { recursive: true })
  return mockHome
}

/**
 * Create a mock .planning directory structure for testing
 * @param {string} baseDir - Directory to create .planning in
 * @returns {Promise<string>} Path to .planning directory
 */
export async function createMockPlanning(baseDir) {
  const planningDir = path.join(baseDir, '.planning')
  await fs.mkdir(path.join(planningDir, 'phases'), { recursive: true })
  return planningDir
}
```

**tests/helpers/setup.js** - Global test setup:
```javascript
// Global test setup
// Runs before all tests via vitest.config.js setupFiles

import { beforeAll, afterAll } from 'vitest'

// Store original environment
const originalEnv = { ...process.env }

beforeAll(() => {
  // Ensure consistent test environment
  // Unset any user-specific paths that might affect tests
  delete process.env.CLAUDE_CONFIG_DIR
  delete process.env.OPENCODE_CONFIG_DIR
  delete process.env.GEMINI_CONFIG_DIR
})

afterAll(() => {
  // Restore original environment
  process.env = originalEnv
})
```
  </action>
  <verify>
Run these checks:
1. `ls tests/helpers/` shows tmpdir.js and setup.js
2. `grep "tmpdirTest" tests/helpers/tmpdir.js` shows the export
3. `grep "beforeAll" tests/helpers/setup.js` shows the setup hook
  </verify>
  <done>Test helpers provide temp directory isolation and consistent test environment.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `npm install` to install vitest
2. Run `npm test` - should complete (may show "no tests" which is expected)
3. Verify package name: `node -p "require('./package.json').name"` returns "get-shit-done-reflect-cc"
4. Verify install script: `node bin/install.js --help` shows help without errors
</verification>

<success_criteria>
- Package.json has fork name and test scripts
- bin entry points to get-shit-done-reflect-cc
- Install script verified to work with fork (reads package.json dynamically)
- Vitest configuration exists and is valid
- Test helpers are in place for subsequent test writing
- npm test command executes without error
</success_criteria>

<output>
After completion, create `.planning/phases/00-deployment-infrastructure/00-01-SUMMARY.md`
</output>
