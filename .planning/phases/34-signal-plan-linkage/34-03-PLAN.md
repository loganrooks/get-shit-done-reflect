---
phase: 34-signal-plan-linkage
plan: 03
type: execute
wave: 2
depends_on: ["34-01"]
files_modified:
  - get-shit-done/workflows/execute-plan.md
  - agents/gsd-signal-synthesizer.md
autonomous: true

must_haves:
  truths:
    - "When a plan with resolves_signals completes execution, the referenced signals automatically update to remediated status"
    - "The synthesizer checks new signals against remediated/verified signals and links recurrences via recurrence_of"
    - "After N phases with no recurrence, remediated signals move to verified status via passive verification"
    - "Recurrence triggers severity escalation (configurable via recurrence_escalation setting)"
    - "Signal mutations respect the mutability boundary -- only lifecycle fields are modified"
  artifacts:
    - path: "get-shit-done/workflows/execute-plan.md"
      provides: "Post-completion signal remediation step"
      contains: "update_resolved_signals"
    - path: "agents/gsd-signal-synthesizer.md"
      provides: "Recurrence detection and passive verification steps"
      contains: "Recurrence Detection"
  key_links:
    - from: "get-shit-done/workflows/execute-plan.md"
      to: "~/.gsd/knowledge/signals/"
      via: "spliceFrontmatter for remediation status updates"
      pattern: "spliceFrontmatter|remediat"
    - from: "agents/gsd-signal-synthesizer.md"
      to: "~/.gsd/knowledge/signals/"
      via: "recurrence detection against remediated signals"
      pattern: "recurrence_of|remediated"
    - from: "get-shit-done/workflows/execute-plan.md"
      to: "~/.gsd/bin/kb-rebuild-index.sh"
      via: "index rebuild after signal mutations"
      pattern: "kb-rebuild-index"
---

<objective>
Add automatic remediation on plan completion and recurrence detection with passive verification to the synthesizer

Purpose: This is the "output" side of the lifecycle -- when plans complete, their declared signals move to remediated status, and the synthesizer detects recurrences and verifies remediations passively. Together with Plan 02 (input side), this completes the lifecycle loop from detected -> triaged -> remediated -> verified.
Output: Updated execute-plan.md with remediation step, updated gsd-signal-synthesizer.md with recurrence detection and passive verification steps
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-signal-plan-linkage/34-RESEARCH.md
@get-shit-done/workflows/execute-plan.md
@agents/gsd-signal-synthesizer.md
@agents/knowledge-store.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add post-completion signal remediation step to execute-plan.md</name>
  <files>get-shit-done/workflows/execute-plan.md</files>
  <action>
Add a new step `update_resolved_signals` to execute-plan.md. Insert it after the `create_summary` step and before the `update_current_position` step. This step processes the resolves_signals array from the completed plan's frontmatter and updates referenced signals to remediated status.

New step content:

```markdown
<step name="update_resolved_signals">
If the completed plan has `resolves_signals` in its PLAN.md frontmatter, update referenced signals to remediated status.

**Skip if:** No `resolves_signals` field in plan frontmatter, or the array is empty.

```bash
# Check for resolves_signals in the plan
RESOLVES=$(node ~/.claude/get-shit-done/bin/gsd-tools.js frontmatter extract "$PLAN_PATH" --field resolves_signals 2>/dev/null)
```

If `RESOLVES` is non-empty, not "null", and not "[]":

1. Parse the signal IDs from the resolves_signals array
2. Read the project's `lifecycle_strictness` from config (default: `flexible`):
   ```bash
   STRICTNESS=$(node -e "try { const c = require('./.planning/config.json'); console.log(c.signal_lifecycle?.lifecycle_strictness || 'flexible') } catch(e) { console.log('flexible') }")
   ```
3. For each signal ID:
   a. Locate the signal file in `~/.gsd/knowledge/signals/{project}/`
   b. If file not found: log warning "Signal {sig-id} not found or archived, skipping remediation update" and continue
   c. Read the signal file content
   d. Parse frontmatter with `extractFrontmatter()` (conceptually -- the workflow instructs the executor to use gsd-tools.js or direct file manipulation)
   e. Check current `lifecycle_state`:
      - If already `remediated`, `verified`, or `invalidated`: skip (log "Signal {sig-id} already {state}, skipping")
      - If `detected` and `STRICTNESS` is `strict`: skip (log "Signal {sig-id} is detected but lifecycle_strictness is strict -- requires triage first")
      - If `detected` and `STRICTNESS` is `flexible` or `minimal`: proceed
      - If `triaged`: proceed (normal path)
   f. Update ONLY mutable lifecycle fields:
      - `lifecycle_state`: "remediated"
      - `remediation.status`: "complete"
      - `remediation.resolved_by_plan`: "{phase}-{plan}" (e.g., "34-01")
      - `remediation.approach`: plan objective from PLAN.md (first line of `<objective>`)
      - `remediation.at`: current ISO-8601 timestamp
      - `lifecycle_log`: append entry "triaged->remediated by executor at {timestamp}: plan {phase}-{plan} completed" (or "detected->remediated" if was detected)
      - `updated`: current ISO-8601 timestamp
   g. Write back using `spliceFrontmatter()` approach (read -> parse -> modify ONLY mutable fields -> splice)
   h. Validate with: `node ~/.claude/get-shit-done/bin/gsd-tools.js frontmatter validate {file} --schema signal`
   i. If validation fails: revert the file to its original content and log warning "Validation failed for {sig-id}, reverted"
4. After all signals processed, rebuild KB index:
   ```bash
   bash ~/.gsd/bin/kb-rebuild-index.sh
   ```
5. Log: "Updated {N} signal(s) to remediated status"

**Key constraints:**
- Signal updates happen at the WORKFLOW level, not in the executor agent. The executor focuses on task execution; the workflow manages lifecycle transitions after completion.
- NEVER modify frozen detection payload fields (severity, tags, evidence, confidence, signal_type, etc.). Only lifecycle fields (lifecycle_state, remediation, lifecycle_log, updated) may change.
- Use the Phase 33 roundtrip validation pattern: read original content, parse, modify only mutable fields, splice, validate, revert on failure.
- Per lesson [les-2026-02-28-plans-must-verify-system-behavior-not-assume]: verify that `frontmatter extract` actually works for array fields before relying on it. If it returns raw YAML, parse accordingly.
</step>
```

Also update the `<success_criteria>` section at the bottom of execute-plan.md to add:
```markdown
- If resolves_signals in plan: referenced signals updated to remediated status (or warnings logged for missing/invalid signals)
```
  </action>
  <verify>
grep "update_resolved_signals" get-shit-done/workflows/execute-plan.md
grep "remediated" get-shit-done/workflows/execute-plan.md
grep "lifecycle_strictness" get-shit-done/workflows/execute-plan.md
grep "kb-rebuild-index" get-shit-done/workflows/execute-plan.md
grep "spliceFrontmatter" get-shit-done/workflows/execute-plan.md
  </verify>
  <done>execute-plan.md has update_resolved_signals step that processes resolves_signals after plan completion, respects lifecycle_strictness, updates only mutable fields, validates after write, and rebuilds the KB index</done>
</task>

<task type="auto">
  <name>Task 2: Add recurrence detection and passive verification to gsd-signal-synthesizer.md</name>
  <files>agents/gsd-signal-synthesizer.md</files>
  <action>
Add two new steps to gsd-signal-synthesizer.md after the existing Step 4 (Within-KB Dedup). These steps implement recurrence detection (LIFECYCLE-04, LIFECYCLE-06) and passive verification-by-absence (LIFECYCLE-05).

**Step 4b: Recurrence Detection** (insert after Step 4, before Step 5):

```markdown
### Step 4b: Recurrence Detection

After within-KB dedup (Step 4), check for recurrences against remediated and verified signals:

1. Read all remediated and verified signals from the KB index:
   - Filter: same project, lifecycle_state = "remediated" or "verified", status = "active"

2. For each new candidate signal, check against each remediated/verified signal:
   - Match criteria: same `signal_type` AND 2+ overlapping tags (same algorithm as cross-sensor dedup in Step 3)
   - If match found:
     a. Set candidate's `recurrence_of` to the matched signal's ID
     b. Read `recurrence_escalation` config:
        ```bash
        # Default: true (from feature-manifest.json)
        ESCALATE=$(node -e "try { const c = require('./.planning/config.json'); console.log(c.signal_lifecycle?.recurrence_escalation !== false) } catch(e) { console.log('true') }")
        ```
     c. If recurrence_escalation is enabled:
        - First recurrence of remediated signal: escalate severity one tier (minor -> notable, notable -> critical, critical stays critical)
        - Recurrence of verified signal: always escalate to critical
     d. Log: "Recurrence detected: {new-summary} matches remediated signal {sig-id}"
     e. Regress the matched remediated/verified signal:
        - Read the matched signal file
        - Update lifecycle_state: "detected" (regression from remediated/verified)
        - If was verified: set verification.status: "failed"
        - Append to lifecycle_log: "{previous_state}->detected by synthesizer at {timestamp}: recurrence detected in phase {N}"
        - Update `updated` timestamp
        - Write back using spliceFrontmatter approach
        - Validate with frontmatter validate --schema signal
        - If validation fails: revert and log warning

3. If any regressions occurred, log count: "Regressed {N} signal(s) due to recurrence"
```

**Step 4c: Passive Verification Check** (insert after Step 4b, before Step 5):

```markdown
### Step 4c: Passive Verification Check

After recurrence detection, check if any remediated signals qualify for verification-by-absence:

1. Read verification_window from project config:
   ```bash
   # Default: 3 phases (from feature-manifest.json)
   WINDOW=$(node -e "try { const c = require('./.planning/config.json'); console.log(c.signal_lifecycle?.verification_window || 3) } catch(e) { console.log(3) }")
   ```

2. Read all remediated signals (lifecycle_state = "remediated", same project, status = "active")

3. For each remediated signal:
   a. Extract remediation phase number from `remediation.resolved_by_plan` (format: "{phase}-{plan}", extract phase number)
   b. If `remediation.resolved_by_plan` is missing or unparseable: skip (cannot determine remediation phase)
   c. Calculate phases_since_remediation = current_phase_number - remediation_phase_number
   d. If phases_since_remediation >= verification_window:
      - Check: was this signal regressed in Step 4b? If yes: skip (already handled)
      - Update signal:
        - lifecycle_state: "verified"
        - verification.status: "passed"
        - verification.method: "absence-of-recurrence"
        - verification.at: current ISO-8601 timestamp
        - Append to lifecycle_log: "remediated->verified by synthesizer at {timestamp}: no recurrence in {N} phases"
        - Update `updated` timestamp
      - Write back, validate, revert on failure (same pattern as Step 4b)

4. Log: "Verified {N} signal(s) by absence of recurrence"
```

Also update the Step 9 (Generate Report) template to include recurrence and verification counts:

Add after "Cap limited:" line:
```markdown
**Recurrences detected:** {N}
**Signals regressed:** {N}
**Signals verified:** {N}
```

And add two new report sections:

```markdown
### Recurrences Detected
| # | New Signal | Matches Remediated | Escalated | Regressed |
|---|-----------|-------------------|-----------|-----------|

### Signals Verified (by absence)
| # | Signal ID | Remediated Phase | Phases Elapsed | Status |
|---|-----------|-----------------|----------------|--------|
```

Update Guideline 5 (mutability boundary) to note that the synthesizer is now authorized to modify existing signal files for both archival (existing) AND recurrence regression / passive verification (new in Phase 34). Update Guideline 6 accordingly to expand the scope:

Change Guideline 6 from "ONLY for archival during cap enforcement" to: "for archival during cap enforcement (Step 6), recurrence regression (Step 4b), and passive verification (Step 4c)."
  </action>
  <verify>
grep "Step 4b" agents/gsd-signal-synthesizer.md
grep "Step 4c" agents/gsd-signal-synthesizer.md
grep "Recurrence Detection" agents/gsd-signal-synthesizer.md
grep "Passive Verification" agents/gsd-signal-synthesizer.md
grep "recurrence_of" agents/gsd-signal-synthesizer.md
grep "verification_window" agents/gsd-signal-synthesizer.md
grep "recurrence_escalation" agents/gsd-signal-synthesizer.md
  </verify>
  <done>gsd-signal-synthesizer.md has Step 4b (recurrence detection with severity escalation and signal regression) and Step 4c (passive verification-by-absence using configurable verification_window), plus updated report template and expanded mutation authorization in guidelines</done>
</task>

</tasks>

<verification>
- [ ] execute-plan.md has update_resolved_signals step positioned after create_summary
- [ ] execute-plan.md respects lifecycle_strictness (strict/flexible/minimal)
- [ ] execute-plan.md updates only mutable lifecycle fields
- [ ] execute-plan.md validates after write and reverts on failure
- [ ] execute-plan.md rebuilds KB index after signal updates
- [ ] synthesizer has Step 4b with recurrence matching (same signal_type + 2+ tags)
- [ ] synthesizer Step 4b escalates severity on recurrence (when enabled)
- [ ] synthesizer Step 4b regresses matched signals to detected state
- [ ] synthesizer has Step 4c with verification_window config read
- [ ] synthesizer Step 4c moves remediated signals to verified after N phases
- [ ] synthesizer report includes recurrence and verification counts
- [ ] synthesizer guidelines updated for expanded mutation authorization
</verification>

<success_criteria>
The lifecycle transition machinery is in place: plan completion triggers remediation, the synthesizer detects recurrences and regresses signals, and passive verification promotes remediated signals to verified after the configured window. Signal mutations respect the mutability boundary throughout.
</success_criteria>

<output>
After completion, create `.planning/phases/34-signal-plan-linkage/34-03-SUMMARY.md`
</output>
