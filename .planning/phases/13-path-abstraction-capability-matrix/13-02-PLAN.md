---
phase: 13-path-abstraction-capability-matrix
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/references/capability-matrix.md
  - get-shit-done/workflows/execute-phase.md
  - get-shit-done/workflows/plan-phase.md
autonomous: true

must_haves:
  truths:
    - "A capability matrix declares task_tool, hooks, tool_permissions, mcp_servers availability for all 4 runtimes"
    - "Each runtime has documented degraded behavior with specific adaptations"
    - "Orchestrator workflows contain capability_check sections for task_tool and hooks"
    - "Feature detection uses has_capability() prose patterns, not runtime name checks"
  artifacts:
    - path: "get-shit-done/references/capability-matrix.md"
      provides: "Runtime capability declarations and degraded behavior documentation for all 4 runtimes"
      contains: "task_tool"
    - path: "get-shit-done/workflows/execute-phase.md"
      provides: "Capability-aware execution orchestration with task_tool and hooks checks"
      contains: "capability_check"
    - path: "get-shit-done/workflows/plan-phase.md"
      provides: "Capability-aware planning orchestration with task_tool check"
      contains: "capability_check"
  key_links:
    - from: "get-shit-done/workflows/execute-phase.md"
      to: "get-shit-done/references/capability-matrix.md"
      via: "capability_check referencing matrix"
      pattern: "capability-matrix\\.md"
    - from: "get-shit-done/workflows/plan-phase.md"
      to: "get-shit-done/references/capability-matrix.md"
      via: "capability_check referencing matrix"
      pattern: "capability-matrix\\.md"
---

<objective>
Create the runtime capability matrix reference document and add feature detection patterns to orchestrator workflows. The matrix declares per-runtime tool availability for all 4 supported runtimes (Claude Code, OpenCode, Gemini CLI, Codex CLI), and orchestrator workflows use capability_check sections to branch behavior based on feature availability.

Purpose: ABST-02 (capability matrix artifact), ABST-03 (feature detection patterns), ABST-04 (degraded behavior documentation). These enable workflows to adapt to runtime limitations rather than assuming Claude Code features are universally available.

Output: New capability-matrix.md reference doc, updated execute-phase.md and plan-phase.md with capability_check sections.
</objective>

<execution_context>
@/Users/rookslog/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rookslog/.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-path-abstraction-capability-matrix/13-RESEARCH.md
@.planning/phases/13-path-abstraction-capability-matrix/13-CONTEXT.md
@get-shit-done/workflows/execute-phase.md
@get-shit-done/workflows/plan-phase.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create the runtime capability matrix reference document</name>
  <files>get-shit-done/references/capability-matrix.md</files>
  <action>
Create `get-shit-done/references/capability-matrix.md` as a new reference document. This is a static markdown file that ships with every GSD installation (installed to the references/ directory alongside existing reference docs).

Structure the document following the research recommendation (Capability Matrix Design section) with these sections:

**Header:**
```
# Runtime Capability Matrix

> Reference document for GSD workflow orchestrators. Declares which features
> are available in each supported runtime. Workflows use `has_capability()`
> patterns to branch behavior based on this matrix.
```

**Section 1: Quick Reference** -- A "Can I Use"-style compatibility table:

| Capability | Claude Code | OpenCode | Gemini CLI | Codex CLI | Impact When Missing |
|------------|:-----------:|:--------:|:----------:|:---------:|---------------------|
| task_tool  |      Y      |    Y     |     Y      |     N     | Sequential execution |
| hooks      |      Y      |    N     |     Y      |     N     | Skip hook features   |
| tool_permissions | Y     |    Y     |     N      |     N     | All tools available  |
| mcp_servers|      Y      |    Y     |     N      |     N     | Skip MCP features    |

**Section 2: Format Reference** -- Per-runtime format details (frontmatter format, command structure, agent format, config format). Use the exact values from the locked decision:
- frontmatter_format: YAML, YAML (tools as map), TOML, SKILL.md
- nested_commands: yes, no (flat), no (flat), no (skills)

| Property | Claude Code | OpenCode | Gemini CLI | Codex CLI |
|----------|-------------|----------|------------|-----------|
| frontmatter | YAML | YAML (tools as map) | TOML | SKILL.md |
| commands | commands/gsd/*.md | command/gsd-*.md | commands/gsd/*.toml | skills/*.md |
| agents | agents/gsd-*.md | agents/gsd-*.md | agents/gsd-*.md | (via AGENTS.md) |
| config | settings.json | opencode.json | settings.json | codex.toml |

**Section 3: Capability Details** -- One subsection per capability with:
- What it does
- Which runtimes have it / don't have it
- Degraded behavior when missing
- How orchestrators should adapt

Cover all 4 capabilities: task_tool, hooks, tool_permissions, mcp_servers. Use the detailed descriptions from the research doc (Section "Capability Matrix Design > Recommended Structure > Capability Details").

**Section 4: Degraded Behavior Summary** -- Per-runtime degraded behavior tables per the locked decision:

**Codex CLI (most constrained):**
| Feature | Status | Adaptation |
|---------|--------|------------|
| Parallel agents | N | Sequential plan execution |
| Hooks | N | Manual update checks |
| Tool permissions | N | All tools available |
| MCP servers | N | MCP features skipped |

**Gemini CLI:**
| Feature | Status | Adaptation |
|---------|--------|------------|
| Tool permissions | N | All tools available |
| MCP servers | N | MCP features skipped |

**OpenCode:**
| Feature | Status | Adaptation |
|---------|--------|------------|
| Hooks | N | Manual update checks |

**Claude Code:** Full capability -- no degradation.

**Section 5: Feature Detection Convention** -- Document the `has_capability()` prose pattern and `<capability_check>` XML tag convention that workflows use. Include a brief example of correct usage. Emphasize: this is a prose convention for LLM-read specs, not a programmatic API.

Follow the "inform once, then adapt silently" strategy in the degraded behavior descriptions.
  </action>
  <verify>
Verify the file exists and contains all required sections:
- `grep -c "task_tool" get-shit-done/references/capability-matrix.md` should return 5+ matches
- `grep -c "has_capability" get-shit-done/references/capability-matrix.md` should return 2+ matches
- `grep -c "capability_check" get-shit-done/references/capability-matrix.md` should return 1+ match
- Confirm all 4 runtimes appear in the Quick Reference table
- Confirm all 4 degraded behavior sections exist (Codex, Gemini, OpenCode, Claude)
  </verify>
  <done>
get-shit-done/references/capability-matrix.md exists with Quick Reference table, Format Reference, Capability Details for all 4 capabilities, Degraded Behavior Summary for all 4 runtimes, and Feature Detection Convention documentation. The document uses the "Can I Use" style and follows the locked decision's capability granularity exactly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add capability_check sections to orchestrator workflows</name>
  <files>get-shit-done/workflows/execute-phase.md, get-shit-done/workflows/plan-phase.md</files>
  <action>
Add `<capability_check>` XML sections to the two main orchestrator workflows. Per the locked decision, capability checks go in workflow orchestrators (NOT in agent specs). Agent specs remain clean and capability-agnostic.

**execute-phase.md:**

Add a `<capability_adaptation>` section (containing capability_check blocks) near the beginning of the execution flow, before the wave execution logic. This section should contain two capability checks:

1. **task_tool check** (parallel execution):
```markdown
<capability_check name="parallel_execution">
Check the runtime capability matrix (get-shit-done/references/capability-matrix.md):

If has_capability("task_tool"):
  Execute waves as designed -- spawn gsd-executor via Task() for each plan in the wave.
  Track agent progress, collect results, proceed to next wave.

Else:
  Note to user (first occurrence only): "Note: Running sequentially -- this runtime doesn't support parallel agents."
  For each plan in execution order:
  1. Read the plan file directly
  2. Execute each task in sequence (follow execute-plan.md flow)
  3. Create SUMMARY.md after all tasks complete
  4. Commit task artifacts
  5. Proceed to next plan
  Skip: wave grouping, parallel spawning, agent tracking
</capability_check>
```

2. **hooks check**:
```markdown
<capability_check name="hooks_support">
If has_capability("hooks"):
  Configure hooks as normal (update check on SessionStart, etc.).

Else:
  Skip hook configuration.
  Note (first occurrence): "Update checks will run on GSD command invocation instead of session start."
</capability_check>
```

**plan-phase.md:**

Add a `<capability_check>` section before the agent spawning logic (where it uses Task() to spawn the researcher and planner agents):

```markdown
<capability_check name="agent_spawning">
Check the runtime capability matrix (get-shit-done/references/capability-matrix.md):

If has_capability("task_tool"):
  Spawn gsd-phase-researcher and gsd-planner via Task() as designed.

Else:
  Note (first occurrence): "Note: Running without parallel agents -- research and planning happen sequentially in this context."
  Instead of spawning agents:
  1. Read the researcher agent spec and perform research inline
  2. Read the planner agent spec and perform planning inline
  3. Continue with plan creation in the same context
</capability_check>
```

**Placement guidelines:**
- Place capability_check sections BEFORE the code they gate (not after)
- Use descriptive `name` attributes for grep-ability
- Always present the standard behavior first (if/else), then the degraded behavior
- Include the "first occurrence only" note pattern per the "inform once, then adapt silently" strategy
- Do NOT add capability checks to agent spec files (gsd-planner.md, gsd-executor.md, etc.) -- those stay capability-agnostic

Read the current content of execute-phase.md and plan-phase.md to find the right insertion points. The capability_adaptation section should be placed where it will be read BEFORE the gated behavior occurs in the workflow flow.
  </action>
  <verify>
Verify capability checks exist in both files:
- `grep -c "capability_check" get-shit-done/workflows/execute-phase.md` should return 2+ matches
- `grep -c "capability_check" get-shit-done/workflows/plan-phase.md` should return 1+ match
- `grep -c "has_capability" get-shit-done/workflows/execute-phase.md` should return 2+ matches
- `grep -c "has_capability" get-shit-done/workflows/plan-phase.md` should return 1+ match
- `grep -c "capability-matrix.md" get-shit-done/workflows/execute-phase.md` should return 1+ match
- Verify NO capability_check sections in agent spec files: `grep -r "capability_check" agents/` should return 0 matches
  </verify>
  <done>
execute-phase.md contains capability_check sections for task_tool (parallel/sequential execution) and hooks. plan-phase.md contains a capability_check section for task_tool (agent spawning). Both reference the capability matrix. No agent spec files contain capability checks.
  </done>
</task>

</tasks>

<verification>
1. `ls get-shit-done/references/capability-matrix.md` -- file exists
2. `grep -c "task_tool" get-shit-done/references/capability-matrix.md` -- 5+ matches (table + details)
3. `grep "capability_check" get-shit-done/workflows/execute-phase.md` -- present
4. `grep "capability_check" get-shit-done/workflows/plan-phase.md` -- present
5. `grep -r "capability_check" agents/` -- zero matches (agent specs clean)
6. All 4 runtimes documented in capability matrix with degraded behavior
</verification>

<success_criteria>
- capability-matrix.md exists at get-shit-done/references/ with Quick Reference table, 4 capability details, degraded behavior per runtime, and feature detection convention
- execute-phase.md has capability_check for task_tool (parallel vs sequential) and hooks
- plan-phase.md has capability_check for task_tool (agent spawning)
- Feature detection uses has_capability() prose patterns, NOT runtime name checks
- Agent specs contain zero capability checks (orchestrators only)
</success_criteria>

<output>
After completion, create `.planning/phases/13-path-abstraction-capability-matrix/13-02-SUMMARY.md`
</output>
