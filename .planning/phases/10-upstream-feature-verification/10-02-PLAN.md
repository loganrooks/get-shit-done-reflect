---
phase: 10-upstream-feature-verification
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: true

must_haves:
  truths:
    - "The writeManifest() function creates SHA256 hashes covering get-shit-done/, commands/gsd/, and agents/gsd-* files"
    - "The saveLocalPatches() function detects modified files by hash comparison and backs them up with backup-meta.json"
    - "The update workflow and gsd-check-update.js both use get-shit-done-reflect-cc as the npm package name"
    - "The parseJsonc() function handles BOM, single-line comments, block comments, and trailing commas without corrupting string contents"
    - "The proactive update notification hook runs on SessionStart and writes cache for statusline display"
  artifacts:
    - path: "bin/install.js"
      provides: "Reapply-patches mechanism (writeManifest, saveLocalPatches, reportLocalPatches) and JSONC parser"
      contains: "writeManifest"
    - path: "get-shit-done/workflows/update.md"
      provides: "Update workflow with fork branding"
      contains: "get-shit-done-reflect-cc"
    - path: "hooks/gsd-check-update.js"
      provides: "Background update check hook"
      contains: "get-shit-done-reflect-cc"
    - path: "commands/gsd/reapply-patches.md"
      provides: "LLM-guided patch reapplication command"
      contains: "gsd-local-patches"
  key_links:
    - from: "bin/install.js writeManifest()"
      to: "gsd-file-manifest.json"
      via: "SHA256 hash generation after install"
      pattern: "writeManifest"
    - from: "bin/install.js saveLocalPatches()"
      to: "gsd-local-patches/backup-meta.json"
      via: "Hash comparison and file backup before reinstall"
      pattern: "saveLocalPatches"
    - from: "hooks/gsd-check-update.js"
      to: "~/.claude/cache/gsd-update-check.json"
      via: "Background npm version check"
      pattern: "gsd-update-check"
---

<objective>
Verify that the reapply-patches mechanism (FEAT-01), update command local/global detection (FEAT-05), and JSONC parsing (FEAT-06) all function correctly in the fork context.

Purpose: These three features share the install.js codebase and the update workflow. FEAT-01 is data-safety critical -- if patch backup fails, users lose their customizations during updates. FEAT-05 must use fork package name to avoid installing upstream. FEAT-06 prevents data loss for OpenCode users.

Output: Verification evidence that all three features work correctly with fork branding and in fork context.
</objective>

<execution_context>
@/Users/rookslog/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rookslog/.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-upstream-feature-verification/10-RESEARCH.md
@bin/install.js
@get-shit-done/workflows/update.md
@hooks/gsd-check-update.js
@commands/gsd/reapply-patches.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify FEAT-01 reapply-patches mechanism</name>
  <files>bin/install.js (read), commands/gsd/reapply-patches.md (read)</files>
  <action>
Verify the complete reapply-patches pipeline by reading and analyzing the source code:

**1. Manifest generation (writeManifest):**
- Read bin/install.js function writeManifest() (around line 1180)
- Verify it covers three directories: get-shit-done/, commands/gsd/, agents/gsd-*
- Verify manifest includes version, timestamp, and files object with SHA256 hashes
- Verify manifest is written to configDir/gsd-file-manifest.json
- Verify the hash function uses SHA256 (crypto.createHash('sha256'))

**2. Patch detection (saveLocalPatches):**
- Read bin/install.js function saveLocalPatches() (around line 1212)
- Verify it reads the manifest and compares current file hashes against stored hashes
- Verify modified files are copied to configDir/gsd-local-patches/{relPath}
- Verify backup-meta.json is created with: backed_up_at, from_version, files array
- Verify the function returns empty array (not error) when no manifest exists

**3. Patch reporting (reportLocalPatches):**
- Read bin/install.js function reportLocalPatches() (around line 1252)
- Verify output message says "Run /gsd:reapply-patches" (correct fork command syntax)
- Verify no upstream branding in output messages (no "get-shit-done-cc" without -reflect)

**4. Reapply command spec:**
- Read commands/gsd/reapply-patches.md
- Verify it checks both global ($HOME/.claude/gsd-local-patches) and local (./.claude/gsd-local-patches)
- Verify merge strategy: read backed-up version + new version, identify user modifications, apply to new version
- Verify conflict handling: flag conflicts, show both versions, ask user
- Verify cleanup option after reapply

**5. Non-destructive functional test:**
- Run the installer's manifest generation on a test path (do NOT actually reinstall):
```bash
node -e "
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');
function fileHash(fp) { return crypto.createHash('sha256').update(fs.readFileSync(fp)).digest('hex'); }
// Test hash of a known file
const testFile = path.join(process.env.HOME, '.claude', 'get-shit-done', 'VERSION');
if (fs.existsSync(testFile)) {
  console.log('VERSION hash:', fileHash(testFile));
  console.log('VERSION content:', fs.readFileSync(testFile, 'utf8').trim());
}
// Check if manifest exists
const manifestPath = path.join(process.env.HOME, '.claude', 'gsd-file-manifest.json');
if (fs.existsSync(manifestPath)) {
  const m = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
  console.log('Manifest version:', m.version);
  console.log('Manifest file count:', Object.keys(m.files).length);
  console.log('Sample files:', Object.keys(m.files).slice(0, 5));
} else {
  console.log('No manifest found (expected if install did not run writeManifest yet)');
}
"
```

**6. Fork branding check:**
- Grep install.js for any instance of upstream package name or URLs in the reapply-patches related functions
- Verify all user-visible messages use fork branding
  </action>
  <verify>
All 6 checks pass:
1. writeManifest covers 3 directory types with SHA256 hashes
2. saveLocalPatches creates backup-meta.json with correct structure
3. reportLocalPatches references /gsd:reapply-patches command
4. reapply-patches.md checks both global and local paths
5. Functional test shows hash generation works
6. No upstream branding in user-visible output
  </verify>
  <done>The reapply-patches mechanism is verified working in fork context: manifest generation covers all GSD directories, patch detection uses SHA256 comparison, backups include metadata for restoration, and the reapply command spec handles merge/conflict resolution correctly</done>
</task>

<task type="auto">
  <name>Task 2: Verify FEAT-05 update detection + FEAT-06 JSONC parsing</name>
  <files>get-shit-done/workflows/update.md (read), hooks/gsd-check-update.js (read), bin/install.js (read)</files>
  <action>
**FEAT-05: Update command local/global detection**

1. Read get-shit-done/workflows/update.md and verify ALL npm/npx references use fork package name:
```bash
grep -n 'get-shit-done' get-shit-done/workflows/update.md
```
Every instance must be `get-shit-done-reflect-cc`, NOT `get-shit-done-cc`.

2. Read hooks/gsd-check-update.js and verify:
- npm view uses `get-shit-done-reflect-cc`
- VERSION file paths check local (./.claude/get-shit-done/VERSION) then global (~/.claude/get-shit-done/VERSION)
- Background spawn with detached:true for proper process detachment
- Cache written to ~/.claude/cache/gsd-update-check.json

3. Verify local/global detection logic in update.md:
- Step 1 checks ./.claude/get-shit-done/VERSION first (local priority)
- Falls back to ~/.claude/get-shit-done/VERSION (global)
- Uses --local or --global flag accordingly for npx install

4. Verify GitHub URL in update.md points to fork repo:
```bash
grep -n 'github.com' get-shit-done/workflows/update.md
```
Must show `loganrooks/get-shit-done-reflect`, not upstream URL.

5. Verify proactive update notification chain:
- gsd-check-update.js is registered as SessionStart hook (check install.js hook registration)
- It spawns background process to check npm registry
- Writes result to gsd-update-check.json with: update_available, installed, latest, checked
- Statusline reads this cache (check if statusline integration exists)

**FEAT-06: JSONC parsing**

6. Read bin/install.js parseJsonc() function (around line 980) and verify it handles:
- BOM stripping (charCodeAt(0) === 0xFEFF)
- Single-line comments (// to end of line)
- Block comments (/* ... */)
- Trailing commas before } or ]
- Strings containing // or /* are NOT stripped (inString tracking)

7. Run JSONC parser test:
```bash
node -e "
// Replicate parseJsonc logic for testing
function parseJsonc(content) {
  if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1);
  let result = '', inString = false, i = 0;
  while (i < content.length) {
    const char = content[i], next = content[i + 1];
    if (inString) {
      result += char;
      if (char === '\\\\' && i + 1 < content.length) { result += next; i += 2; continue; }
      if (char === '\"') inString = false;
      i++;
    } else {
      if (char === '\"') { inString = true; result += char; i++; }
      else if (char === '/' && next === '/') { while (i < content.length && content[i] !== '\\n') i++; }
      else if (char === '/' && next === '*') { i += 2; while (i < content.length - 1 && !(content[i] === '*' && content[i + 1] === '/')) i++; i += 2; }
      else { result += char; i++; }
    }
  }
  result = result.replace(/,(\\s*[}\\]])/g, '\$1');
  return JSON.parse(result);
}

// Test cases
const tests = [
  { name: 'basic', input: '{\"a\": 1}', expected: {a: 1} },
  { name: 'single-line comment', input: '{\"a\": 1 // comment\\n}', expected: {a: 1} },
  { name: 'block comment', input: '{\"a\": /* comment */ 1}', expected: {a: 1} },
  { name: 'trailing comma', input: '{\"a\": 1,}', expected: {a: 1} },
  { name: 'string with //', input: '{\"url\": \"https://example.com\"}', expected: {url: 'https://example.com'} },
];

let passed = 0;
for (const t of tests) {
  try {
    const result = parseJsonc(t.input);
    const match = JSON.stringify(result) === JSON.stringify(t.expected);
    console.log(match ? 'PASS' : 'FAIL', t.name);
    if (match) passed++;
  } catch (e) { console.log('FAIL', t.name, e.message); }
}
console.log(passed + '/' + tests.length + ' passed');
"
```

8. Check if upstream test suite covers JSONC parsing:
```bash
grep -n 'parseJsonc\|jsonc\|JSONC' get-shit-done/bin/gsd-tools.test.js
```
  </action>
  <verify>
1. All npm/npx references in update.md use get-shit-done-reflect-cc
2. gsd-check-update.js uses fork package name
3. Local/global detection checks correct VERSION file paths
4. GitHub URL points to fork repo
5. Update notification chain is complete (hook -> cache -> statusline)
6. parseJsonc handles all edge cases (5/5 tests pass)
  </verify>
  <done>Update command uses fork branding throughout (get-shit-done-reflect-cc, loganrooks/get-shit-done-reflect), local/global detection works correctly, proactive update notification chain is complete, and JSONC parser handles all edge cases (BOM, comments, trailing commas, string preservation)</done>
</task>

</tasks>

<verification>
1. No instance of upstream package name (get-shit-done-cc without -reflect) in update-related files
2. Reapply-patches pipeline verified end-to-end (manifest -> detection -> backup -> command)
3. JSONC parser handles all edge cases
4. All tests still pass: `npx vitest run` and `node --test get-shit-done/bin/gsd-tools.test.js`
</verification>

<success_criteria>
- Reapply-patches: manifest covers all GSD directories, backup creates metadata, command spec correct
- Update: fork package name in all references, local/global detection verified, notification chain complete
- JSONC: all edge cases handled (BOM, comments, trailing commas, string preservation)
- All 117 tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/10-upstream-feature-verification/10-02-SUMMARY.md`
</output>
