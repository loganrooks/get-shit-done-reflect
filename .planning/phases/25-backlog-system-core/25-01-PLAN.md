---
phase: 25-backlog-system-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/bin/gsd-tools.js
  - get-shit-done/bin/gsd-tools.test.js
autonomous: true

must_haves:
  truths:
    - "backlog add creates a Markdown file with correct YAML frontmatter (id, title, tags, theme, priority, status, source, promoted_to, created, updated) in .planning/backlog/items/"
    - "backlog list returns items with filtering by priority, status, and tags"
    - "backlog update modifies frontmatter fields of an existing backlog item and updates the 'updated' timestamp"
    - "backlog stats shows counts grouped by status and priority across project-local items"
    - "cmdListTodos and cmdInitTodos auto-default priority to MEDIUM, source to unknown, and status to pending for existing todos missing those fields"
    - "backlog add handles filename collision by appending numeric suffix"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "resolveBacklogDir, readBacklogItems, cmdBacklogAdd, cmdBacklogList, cmdBacklogUpdate, cmdBacklogStats functions and backlog CLI dispatch"
      contains: "resolveBacklogDir"
    - path: "get-shit-done/bin/gsd-tools.test.js"
      provides: "Tests for backlog add, list, update, stats commands and todo auto-defaults"
      contains: "backlog add"
  key_links:
    - from: "cmdBacklogAdd"
      to: "resolveBacklogDir"
      via: "path resolution for items directory"
      pattern: "resolveBacklogDir\\("
    - from: "cmdBacklogAdd"
      to: "generateSlugInternal"
      via: "filename slug generation from title"
      pattern: "generateSlugInternal\\("
    - from: "cmdBacklogList"
      to: "extractFrontmatter"
      via: "frontmatter parsing when reading items"
      pattern: "extractFrontmatter\\("
    - from: "main() case 'backlog'"
      to: "cmdBacklogAdd, cmdBacklogList, cmdBacklogUpdate, cmdBacklogStats"
      via: "CLI subcommand dispatch"
      pattern: "case 'backlog'"
---

<objective>
Build the core backlog CRUD commands (add, list, update, stats), helper functions (resolveBacklogDir, readBacklogItems), CLI dispatch, and extend the todo system to auto-default priority/source/status for existing todos.

Purpose: This is the foundation for the entire backlog system. All other backlog features (group, promote, index, global, workflow integration) build on the helpers and CRUD commands created here.

Output: Working backlog add/list/update/stats commands with tests, resolveBacklogDir and readBacklogItems helpers, todo auto-default extensions, and CLI router wiring.

**Approach: TDD** -- write all tests first (Task 1), then implement to make them pass (Task 2).
</objective>

<execution_context>
@/Users/rookslog/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rookslog/.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-backlog-system-core/25-RESEARCH.md
@get-shit-done/bin/gsd-tools.js
@get-shit-done/bin/gsd-tools.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for backlog add, list, update, stats and todo auto-defaults</name>
  <files>
    get-shit-done/bin/gsd-tools.test.js
  </files>
  <action>
**TDD RED phase:** Write all tests first. They WILL fail because `backlog` commands do not exist yet. That is expected and correct.

Add a new `describe('backlog add command', ...)` block and sibling describe blocks after the existing test blocks at the end of the file. Use the existing `createTempProject` and `cleanup` helpers. Each describe block should have `beforeEach`/`afterEach` for temp directory setup/teardown.

**Tests for `backlog add` (6 tests):**

1. **creates backlog item with all frontmatter fields**: Run `backlog add --title "Add auth refresh" --tags "auth,security" --priority HIGH --theme "authentication" --source "conversation"`, verify JSON output has `created: true` and `id` starting with `blog-`. Read the created file, verify frontmatter contains: id, title, tags (array), theme, priority, status (captured), source, promoted_to (null), created (ISO string), updated (ISO string).

2. **uses correct filename format (date-slug.md)**: Run `backlog add --title "Fix login bug"`, verify the created file matches pattern `YYYY-MM-DD-fix-login-bug.md`.

3. **handles filename collision with numeric suffix**: Create two items with the same title on the same day. First should create `YYYY-MM-DD-slug.md`, second should create `YYYY-MM-DD-slug-2.md`. Verify both files exist.

4. **defaults priority to MEDIUM when not specified**: Run `backlog add --title "Some idea"` (no --priority), read file, verify frontmatter has `priority: MEDIUM`.

5. **defaults source to command when not specified**: Run `backlog add --title "Some idea"` (no --source), read file, verify frontmatter has `source: command`.

6. **creates .planning/backlog/items/ directory if missing**: Run `backlog add --title "First item"` on a temp project that has no backlog directory, verify directory was created and file exists.

**Tests for `backlog list` (5 tests):**

7. **returns empty list when no items**: Run `backlog list` on empty project, verify `count: 0, items: []`.

8. **returns all items**: Create 2 backlog items via files (not via the add command -- write files directly to avoid depending on add), run `backlog list`, verify `count: 2` and both items returned with correct fields.

9. **filters by priority**: Create one HIGH and one LOW item, run `backlog list --priority HIGH`, verify only HIGH item returned.

10. **filters by status**: Create one captured and one triaged item, run `backlog list --status triaged`, verify only triaged item returned.

11. **filters by tags**: Create one item with tags [auth, api] and one with [ui], run `backlog list --tags "auth"`, verify only the auth-tagged item returned.

**Tests for `backlog update` (2 tests):**

12. **updates frontmatter fields**: Create a backlog item file, run `backlog update <id> --priority LOW --status triaged`, read file, verify priority is LOW and status is triaged.

13. **updates the 'updated' timestamp**: Create a backlog item file with a known created/updated timestamp, run `backlog update <id> --status triaged`, read file, verify `updated` field is newer than the original.

**Tests for `backlog stats` (2 tests):**

14. **returns counts by status and priority**: Create 2 captured+HIGH items and 1 triaged+LOW item, run `backlog stats`, verify `total: 3`, `by_status.captured: 2`, `by_status.triaged: 1`, `by_priority.HIGH: 2`, `by_priority.LOW: 1`.

15. **returns zero counts when no items**: Run `backlog stats` on empty project, verify `total: 0`.

**Tests for todo auto-defaults (2 tests):**

16. **cmdListTodos includes priority, source, status with defaults**: Create a todo file in `.planning/todos/pending/` with ONLY created, title, area fields (no priority/source/status). Run `list-todos`, verify each todo object in the output has `priority: "MEDIUM"`, `source: "unknown"`, `status: "pending"`.

17. **cmdInitTodos includes priority, source, status with defaults**: Create a todo file in `.planning/todos/pending/` with ONLY created, title, area. Run `init todos`, verify each todo in the `todos` array has `priority: "MEDIUM"`, `source: "unknown"`, `status: "pending"`.

**Helper for creating backlog item files directly:**

Create a helper function `createBacklogItem(tmpDir, overrides)` that writes a Markdown file with YAML frontmatter to `.planning/backlog/items/`. This avoids dependency on the `backlog add` command for tests that need pre-existing items (list, update, stats tests).

```javascript
function createBacklogItem(tmpDir, overrides = {}) {
  const itemsDir = path.join(tmpDir, '.planning', 'backlog', 'items');
  fs.mkdirSync(itemsDir, { recursive: true });
  const date = '2026-02-22';
  const slug = (overrides.title || 'test-item').toLowerCase().replace(/\s+/g, '-');
  const id = overrides.id || `blog-${date}-${slug}`;
  const filename = `${date}-${slug}.md`;
  const content = `---
id: ${id}
title: ${overrides.title || 'Test item'}
tags: [${(overrides.tags || []).join(', ')}]
theme: ${overrides.theme || 'general'}
priority: ${overrides.priority || 'MEDIUM'}
status: ${overrides.status || 'captured'}
source: ${overrides.source || 'command'}
promoted_to: ${overrides.promoted_to || 'null'}
created: ${overrides.created || '2026-02-22T10:00:00.000Z'}
updated: ${overrides.updated || '2026-02-22T10:00:00.000Z'}
---

## Description

Test backlog item.
`;
  fs.writeFileSync(path.join(itemsDir, filename), content, 'utf-8');
  return { id, filename, itemsDir };
}
```

**After writing all tests, run the test suite:** `node --test get-shit-done/bin/gsd-tools.test.js`. The 17 new tests MUST fail (commands don't exist yet). All existing tests MUST still pass.
  </action>
  <verify>
1. Run: `node --test get-shit-done/bin/gsd-tools.test.js 2>&1 | tail -10` -- 17 new backlog/todo tests fail, all existing tests still pass
2. `grep -c 'backlog' get-shit-done/bin/gsd-tools.test.js` returns 15+ (test describes + assertions)
3. `grep -c 'auto-default\|priority.*MEDIUM\|source.*unknown' get-shit-done/bin/gsd-tools.test.js` returns 4+ (todo auto-default tests)
  </verify>
  <done>
17 tests written and confirmed failing: 6 for backlog add (all fields, filename, collision, defaults, directory creation), 5 for backlog list (empty, all, filter by priority/status/tags), 2 for backlog update (fields, timestamp), 2 for backlog stats (counts, empty), 2 for todo auto-defaults (list-todos, init todos). Existing test suite still passes. TDD red phase complete.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement backlog add, list, update, stats commands + helpers + todo extensions to make all tests pass</name>
  <files>
    get-shit-done/bin/gsd-tools.js
  </files>
  <action>
**TDD GREEN phase:** Implement the minimum code to make all 17 tests pass.

**Part A: Add resolveBacklogDir helper**

Add near other helper functions (after `generateSlugInternal`, around line 3670):

```javascript
function resolveBacklogDir(cwd, isGlobal) {
  if (isGlobal) {
    const gsdHome = process.env.GSD_HOME || path.join(require('os').homedir(), '.gsd');
    return path.join(gsdHome, 'backlog', 'items');
  }
  return path.join(cwd, '.planning', 'backlog', 'items');
}
```

**Part B: Add readBacklogItems shared reader**

Add after resolveBacklogDir:

```javascript
function readBacklogItems(cwd, isGlobal) {
  const itemsDir = resolveBacklogDir(cwd, isGlobal);
  const items = [];
  try {
    const files = fs.readdirSync(itemsDir).filter(f => f.endsWith('.md'));
    for (const file of files) {
      try {
        const content = fs.readFileSync(path.join(itemsDir, file), 'utf-8');
        const fm = extractFrontmatter(content);
        items.push({
          id: fm.id || file.replace('.md', ''),
          title: fm.title || 'Untitled',
          priority: fm.priority || 'MEDIUM',
          status: fm.status || 'captured',
          tags: Array.isArray(fm.tags) ? fm.tags : [],
          theme: fm.theme || null,
          source: fm.source || 'unknown',
          promoted_to: fm.promoted_to === 'null' ? null : (fm.promoted_to || null),
          created: fm.created || 'unknown',
          updated: fm.updated || 'unknown',
          file,
        });
      } catch {}
    }
  } catch {}
  return items;
}
```

**Part C: Add cmdBacklogAdd**

```javascript
function cmdBacklogAdd(cwd, options, raw) {
  const { title, tags, priority, theme, source, global: isGlobal } = options;
  if (!title) { error('--title required for backlog add'); }

  const itemsDir = resolveBacklogDir(cwd, isGlobal);
  fs.mkdirSync(itemsDir, { recursive: true });

  const now = new Date();
  const date = now.toISOString().split('T')[0];
  const slug = generateSlugInternal(title);
  const id = `blog-${date}-${slug}`;

  // Check for collision
  let filename = `${date}-${slug}.md`;
  let fullPath = path.join(itemsDir, filename);
  let counter = 2;
  while (fs.existsSync(fullPath)) {
    filename = `${date}-${slug}-${counter}.md`;
    fullPath = path.join(itemsDir, filename);
    counter++;
  }

  const tagArray = tags ? tags.split(',').map(t => t.trim()) : [];
  const frontmatter = {
    id,
    title,
    tags: tagArray,
    theme: theme || null,
    priority: (priority || 'MEDIUM').toUpperCase(),
    status: 'captured',
    source: source || 'command',
    promoted_to: null,
    created: now.toISOString(),
    updated: now.toISOString(),
  };

  const fmStr = reconstructFrontmatter(frontmatter);
  const content = `---\n${fmStr}\n---\n\n## Description\n\n_No description provided._\n`;

  fs.writeFileSync(fullPath, content, 'utf-8');

  output({
    created: true,
    id,
    file: filename,
    path: fullPath,
    global: isGlobal || false,
  }, raw, id);
}
```

**Part D: Add cmdBacklogList**

```javascript
function cmdBacklogList(cwd, filters, raw) {
  const { priority, status, tags, global: isGlobal } = filters;
  const allItems = readBacklogItems(cwd, isGlobal);

  const items = allItems.filter(item => {
    if (priority && item.priority !== priority.toUpperCase()) return false;
    if (status && item.status !== status) return false;
    if (tags) {
      const filterTags = tags.split(',').map(t => t.trim());
      if (!filterTags.some(ft => item.tags.includes(ft))) return false;
    }
    return true;
  });

  output({ count: items.length, items }, raw, items.length.toString());
}
```

**Part E: Add cmdBacklogUpdate**

```javascript
function cmdBacklogUpdate(cwd, itemId, updates, raw) {
  if (!itemId) { error('item ID required for backlog update'); }

  const itemsDir = resolveBacklogDir(cwd, false);
  let targetFile = null;
  let targetPath = null;

  try {
    const files = fs.readdirSync(itemsDir).filter(f => f.endsWith('.md'));
    for (const file of files) {
      const content = fs.readFileSync(path.join(itemsDir, file), 'utf-8');
      const fm = extractFrontmatter(content);
      if (fm.id === itemId) {
        targetFile = file;
        targetPath = path.join(itemsDir, file);
        break;
      }
    }
  } catch {}

  if (!targetPath) { error(`Backlog item not found: ${itemId}`); }

  const content = fs.readFileSync(targetPath, 'utf-8');
  const fm = extractFrontmatter(content);

  // Apply updates
  const updatedFields = [];
  for (const [key, value] of Object.entries(updates)) {
    if (value !== undefined && value !== null) {
      fm[key] = key === 'priority' ? value.toUpperCase() : value;
      updatedFields.push(key);
    }
  }
  fm.updated = new Date().toISOString();

  // Reconstruct file content (preserve body after frontmatter)
  const bodyMatch = content.match(/^---\n[\s\S]+?\n---\n([\s\S]*)$/);
  const body = bodyMatch ? bodyMatch[1] : '\n\n## Description\n\n_No description provided._\n';
  const fmStr = reconstructFrontmatter(fm);
  const newContent = `---\n${fmStr}\n---\n${body}`;

  fs.writeFileSync(targetPath, newContent, 'utf-8');

  output({
    updated: true,
    id: itemId,
    fields: updatedFields,
    file: targetFile,
  }, raw, itemId);
}
```

**Part F: Add cmdBacklogStats**

```javascript
function cmdBacklogStats(cwd, raw) {
  const localItems = readBacklogItems(cwd, false);
  const globalItems = readBacklogItems(cwd, true);
  const allItems = [...localItems, ...globalItems];

  const byStatus = {};
  const byPriority = {};
  for (const item of allItems) {
    const s = item.status || 'captured';
    const p = item.priority || 'MEDIUM';
    byStatus[s] = (byStatus[s] || 0) + 1;
    byPriority[p] = (byPriority[p] || 0) + 1;
  }

  output({
    total: allItems.length,
    local: localItems.length,
    global: globalItems.length,
    by_status: byStatus,
    by_priority: byPriority,
  }, raw, `${allItems.length} items`);
}
```

**Part G: Wire into CLI router**

In the main `switch` block, add a new `case 'backlog':` before the `default:` case. Follow the exact pattern from the `manifest` case. Parse subcommand from `args[1]`, parse flags from args:

```javascript
case 'backlog': {
  const subcommand = args[1];
  if (subcommand === 'add') {
    const titleIdx = args.indexOf('--title');
    const tagsIdx = args.indexOf('--tags');
    const priorityIdx = args.indexOf('--priority');
    const themeIdx = args.indexOf('--theme');
    const sourceIdx = args.indexOf('--source');
    const globalFlag = args.includes('--global');
    cmdBacklogAdd(cwd, {
      title: titleIdx !== -1 ? args[titleIdx + 1] : null,
      tags: tagsIdx !== -1 ? args[tagsIdx + 1] : null,
      priority: priorityIdx !== -1 ? args[priorityIdx + 1] : 'MEDIUM',
      theme: themeIdx !== -1 ? args[themeIdx + 1] : null,
      source: sourceIdx !== -1 ? args[sourceIdx + 1] : 'command',
      global: globalFlag,
    }, raw);
  } else if (subcommand === 'list') {
    const priorityIdx = args.indexOf('--priority');
    const statusIdx = args.indexOf('--status');
    const tagsIdx = args.indexOf('--tags');
    const globalFlag = args.includes('--global');
    cmdBacklogList(cwd, {
      priority: priorityIdx !== -1 ? args[priorityIdx + 1] : null,
      status: statusIdx !== -1 ? args[statusIdx + 1] : null,
      tags: tagsIdx !== -1 ? args[tagsIdx + 1] : null,
      global: globalFlag,
    }, raw);
  } else if (subcommand === 'update') {
    const itemId = args[2];
    const priorityIdx = args.indexOf('--priority');
    const statusIdx = args.indexOf('--status');
    const themeIdx = args.indexOf('--theme');
    const tagsIdx = args.indexOf('--tags');
    cmdBacklogUpdate(cwd, itemId, {
      priority: priorityIdx !== -1 ? args[priorityIdx + 1] : undefined,
      status: statusIdx !== -1 ? args[statusIdx + 1] : undefined,
      theme: themeIdx !== -1 ? args[themeIdx + 1] : undefined,
      tags: tagsIdx !== -1 ? args[tagsIdx + 1].split(',').map(t => t.trim()) : undefined,
    }, raw);
  } else if (subcommand === 'stats') {
    cmdBacklogStats(cwd, raw);
  } else {
    error('Unknown backlog subcommand. Available: add, list, update, stats, group, promote, index');
  }
  break;
}
```

**Part H: Extend cmdListTodos with auto-defaults (BLOG-05)**

In `cmdListTodos` (around line 628), add regex matches for priority, source, and status after the existing area match. Include them in the todo object pushed to the array with defaults:

```javascript
const priorityMatch = content.match(/^priority:\s*(.+)$/m);
const sourceMatch = content.match(/^source:\s*(.+)$/m);
const statusMatch = content.match(/^status:\s*(.+)$/m);

todos.push({
  file,
  created: createdMatch ? createdMatch[1].trim() : 'unknown',
  title: titleMatch ? titleMatch[1].trim() : 'Untitled',
  area: todoArea,
  priority: priorityMatch ? priorityMatch[1].trim() : 'MEDIUM',
  source: sourceMatch ? sourceMatch[1].trim() : 'unknown',
  status: statusMatch ? statusMatch[1].trim() : 'pending',
  path: path.join('.planning', 'todos', 'pending', file),
});
```

**Part I: Extend cmdInitTodos with auto-defaults (BLOG-05)**

In `cmdInitTodos` (around line 4063), apply the same pattern. Add regex matches for priority, source, and status. Include them in the todo object with defaults.

**Part J: Run tests -- all 17 must now pass**

Run the full test suite. All 17 new tests must pass. All existing tests must still pass. If any test fails, fix the implementation (not the test) until green.
  </action>
  <verify>
1. Run `node --test get-shit-done/bin/gsd-tools.test.js` -- ALL tests pass (0 failures), including the 17 new backlog/todo tests
2. Run `grep -c 'resolveBacklogDir\|readBacklogItems\|cmdBacklogAdd\|cmdBacklogList\|cmdBacklogUpdate\|cmdBacklogStats' get-shit-done/bin/gsd-tools.js` -- returns 6+ (function declarations)
3. Run `grep "case 'backlog'" get-shit-done/bin/gsd-tools.js` -- returns 1 match (CLI dispatch)
4. Manual smoke test: `cd /tmp && mkdir -p .planning && node /Users/rookslog/Development/get-shit-done-reflect/get-shit-done/bin/gsd-tools.js backlog add --title "Test idea" --tags "test" --priority HIGH` -- should create file
5. Run `node get-shit-done/bin/gsd-tools.js list-todos --raw` in a project with existing todos -- verify priority/source/status fields appear with defaults
  </verify>
  <done>
TDD green phase complete. All 17 tests pass. backlog add creates Markdown files with full YAML frontmatter, correct filename format, and collision handling. backlog list supports filtering by priority, status, and tags. backlog update modifies fields and updates timestamp. backlog stats reports counts by status and priority. cmdListTodos and cmdInitTodos auto-default priority, source, and status for legacy todos. CLI dispatch routes all backlog subcommands. No regressions in existing tests.
  </done>
</task>

</tasks>

<verification>
1. Existing test suite passes: `node --test get-shit-done/bin/gsd-tools.test.js` -- no regressions
2. backlog add works: `node gsd-tools.js backlog add --title "Test" --tags "a,b" --priority HIGH --raw` produces valid JSON with `created: true`
3. backlog list works: `node gsd-tools.js backlog list --raw` produces valid JSON with `count` and `items`
4. backlog update works: `node gsd-tools.js backlog update <id> --status triaged --raw` produces valid JSON with `updated: true`
5. backlog stats works: `node gsd-tools.js backlog stats --raw` produces valid JSON with `total`, `by_status`, `by_priority`
6. Todo auto-defaults work: `node gsd-tools.js list-todos --raw` includes priority/source/status on each todo
</verification>

<success_criteria>
- TDD: Tests written BEFORE implementation, confirmed failing, then implementation makes them pass
- backlog add creates Markdown files with all required frontmatter fields (BLOG-01)
- backlog add handles filename collision with numeric suffix
- backlog list supports filter by priority, status, tags
- backlog update modifies fields and updates timestamp
- backlog stats reports counts by status and priority
- cmdListTodos and cmdInitTodos include priority/source/status with auto-defaults (BLOG-05)
- CLI dispatch routes backlog subcommands correctly
- 17+ tests pass for backlog commands and todo auto-defaults
</success_criteria>

<output>
After completion, create `.planning/phases/25-backlog-system-core/25-01-SUMMARY.md`
</output>
