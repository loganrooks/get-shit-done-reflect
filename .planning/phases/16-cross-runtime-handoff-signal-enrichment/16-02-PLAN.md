---
phase: 16-cross-runtime-handoff-signal-enrichment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .claude/agents/kb-templates/signal.md
  - .claude/agents/knowledge-store.md
  - get-shit-done/references/signal-detection.md
  - .claude/agents/gsd-signal-collector.md
  - get-shit-done/workflows/signal.md
  - get-shit-done/workflows/execute-phase.md
autonomous: true

must_haves:
  truths:
    - "Signal template includes optional runtime: and model: fields"
    - "Signal collector agent populates runtime and model when creating signals"
    - "Manual signal workflow populates runtime and model when creating signals"
    - "capability-gap is a valid signal_type in the schema"
    - "Capability gap events are logged as trace-severity signals during degraded execution"
    - "Existing signals without runtime/model fields remain valid (backward compatible)"
  artifacts:
    - path: ".claude/agents/kb-templates/signal.md"
      provides: "Extended signal template with runtime/model fields"
      contains: "runtime:"
    - path: ".claude/agents/knowledge-store.md"
      provides: "Updated signal extensions table with runtime/model"
      contains: "runtime"
    - path: "get-shit-done/references/signal-detection.md"
      provides: "capability-gap signal type documentation"
      contains: "capability-gap"
    - path: ".claude/agents/gsd-signal-collector.md"
      provides: "Runtime/model population in automatic signal collection"
      contains: "runtime"
    - path: "get-shit-done/workflows/signal.md"
      provides: "Runtime/model population in manual signal creation"
      contains: "runtime"
    - path: "get-shit-done/workflows/execute-phase.md"
      provides: "Capability gap signal logging in degraded execution"
      contains: "capability-gap"
  key_links:
    - from: ".claude/agents/gsd-signal-collector.md"
      to: ".claude/agents/kb-templates/signal.md"
      via: "uses template to create signal entries with runtime/model fields"
      pattern: "runtime.*model"
    - from: "get-shit-done/workflows/execute-phase.md"
      to: "signal logging"
      via: "logs capability-gap signals in capability_check Else branches"
      pattern: "capability-gap"
---

<objective>
Enrich the signal schema with runtime provenance metadata (runtime and model fields) and add capability-gap as a signal type, enabling cross-runtime debugging and tracking of degraded execution events.

Purpose: When signals are collected from multiple runtimes, knowing which runtime and model generated each signal is essential for debugging cross-runtime issues. Capability gap signals capture when a runtime lacks a feature, providing data for future runtime support improvements.

Output: Updated signal template, schema documentation, detection references, collector/workflow agents, and execute-phase with capability gap logging.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-cross-runtime-handoff-signal-enrichment/16-RESEARCH.md

# Source files being modified
@.claude/agents/kb-templates/signal.md
@.claude/agents/knowledge-store.md
@get-shit-done/references/signal-detection.md
@.claude/agents/gsd-signal-collector.md
@get-shit-done/workflows/signal.md
@get-shit-done/workflows/execute-phase.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend signal schema with runtime/model fields and capability-gap type</name>
  <files>
    .claude/agents/kb-templates/signal.md
    .claude/agents/knowledge-store.md
    get-shit-done/references/signal-detection.md
  </files>
  <action>
Update THREE files to extend the signal schema:

**File 1: `.claude/agents/kb-templates/signal.md`**

Add two new optional fields to the YAML frontmatter, AFTER the `plan:` field and BEFORE the closing `---`:

```yaml
---
id: sig-{YYYY-MM-DD}-{slug}
type: signal
project: {project-name}
tags: [{tag1}, {tag2}]
created: {YYYY-MM-DDTHH:MM:SSZ}
updated: {YYYY-MM-DDTHH:MM:SSZ}
durability: {workaround|convention|principle}
status: active
severity: {critical|notable}
signal_type: {deviation|struggle|config-mismatch|capability-gap|custom}
phase: {phase-number}
plan: {plan-number}
runtime: {claude-code|opencode|gemini-cli|codex-cli}
model: {model-identifier}
---
```

Changes from current:
- `severity` enum: change from `{critical|high|medium|low}` to `{critical|notable}` (aligns with signal-detection.md Section 6 which only uses critical/notable/trace, and trace is not persisted)
- `signal_type` enum: add `capability-gap` to the list
- Add `runtime:` field after `plan:`
- Add `model:` field after `runtime:`
- Body sections (What Happened, Context, Potential Cause) remain unchanged

**File 2: `.claude/agents/knowledge-store.md`**

In Section 4 "Type-Specific Extensions" > "Signal Extensions" table, add two new rows:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `runtime` | enum | no | Runtime that generated this signal: `claude-code`, `opencode`, `gemini-cli`, or `codex-cli` |
| `model` | enum | no | LLM model identifier (e.g., `claude-opus-4-6`, `o3`) |

Also update the `signal_type` row description to include `capability-gap` in the enum list:
- Change: `deviation`, `struggle`, `config-mismatch`, or `custom`
- To: `deviation`, `struggle`, `config-mismatch`, `capability-gap`, or `custom`

**File 3: `get-shit-done/references/signal-detection.md`**

Make THREE additions:

(a) In Section 8 "Signal Schema Extensions", add two new rows to the extensions table:

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `runtime` | enum: claude-code, opencode, gemini-cli, codex-cli | (omitted) | Runtime that generated this signal. Inferred from workflow file path prefix. Optional -- omit if unknown. |
| `model` | string | (omitted) | LLM model identifier. Self-reported by the executing model. Optional -- omit if unknown. |

Add a compatibility note after the table: "These fields are optional. Existing signals without runtime/model fields remain valid. Agents that do not recognize these fields can safely ignore them."

(b) In Section 6 "Severity Auto-Assignment", add a new row to the severity table:

| Condition | Severity |
|-----------|----------|
| Capability gap (known runtime limitation) | trace |

(c) Add a NEW Section 12 titled "Capability Gap Detection (SGNL-07)" AFTER Section 11:

```markdown
## 12. Capability Gap Detection (SGNL-07)

Detects when a runtime lacks a required capability and degrades gracefully.

**Detection source:** `execute-phase.md` capability_check blocks, specifically the Else branches.

**Signal properties:**
- `signal_type: capability-gap`
- `severity: trace` (known limitations, not errors -- logged in collection report only, NOT persisted to KB)
- `polarity: neutral` (expected behavior, not positive or negative)
- `runtime:` set to the detected runtime

**Detection points:**

| Capability | Detection Location | Description |
|------------|-------------------|-------------|
| `task_tool` | execute-phase.md capability_check "parallel_execution" Else | Parallel wave execution unavailable, degraded to sequential |
| `hooks` | execute-phase.md capability_check "hooks_support" Else | Hook-based update checks unavailable |

**Escalation:** If a capability gap causes an actual execution failure (not just degradation), the resulting signal should be elevated to `notable` or `critical` severity based on impact. Trace is only for expected, handled degradation.

**Important:** Capability gap signals are trace-severity by design. They are NOT persisted to the KB to avoid flooding with repetitive "no task_tool in Codex" entries. They appear in signal collection reports only. If cross-runtime analytics become important in a future milestone, the severity can be re-evaluated.
```

Also add `capability-gap` to any places in the file that list the signal_type enum values. In Section 1 Overview, the input artifacts description mentions signal types -- if there is an explicit enum listing there, add capability-gap. In Section 2, the detection points table header mentions signal types -- add capability-gap there too if it lists them.
  </action>
  <verify>
```bash
# Verify runtime and model fields in signal template
grep -c 'runtime:' .claude/agents/kb-templates/signal.md

# Verify capability-gap in signal template
grep -c 'capability-gap' .claude/agents/kb-templates/signal.md

# Verify knowledge-store has runtime/model in signal extensions
grep -c 'runtime' .claude/agents/knowledge-store.md

# Verify new Section 12 in signal-detection.md
grep -c 'Capability Gap Detection' get-shit-done/references/signal-detection.md

# Verify capability-gap in severity table
grep 'capability.*gap.*trace' get-shit-done/references/signal-detection.md | head -1
```

All grep commands should return >= 1 match.
  </verify>
  <done>
- Signal template has runtime: and model: optional fields
- Signal template has capability-gap in signal_type enum
- Signal template severity enum aligned to critical|notable (matching actual usage)
- knowledge-store.md signal extensions table includes runtime and model rows
- signal-detection.md has Section 12 for capability gap detection
- signal-detection.md severity table includes capability gap -> trace mapping
- All changes are backward compatible (new fields optional, no migration needed)
- Requirements covered: SIG-03 (template updated), partial SIG-01/SIG-02 (schema defined)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add runtime/model population to signal collector and manual signal workflow</name>
  <files>
    .claude/agents/gsd-signal-collector.md
    get-shit-done/workflows/signal.md
  </files>
  <action>
Update TWO files to populate runtime and model fields when creating signals:

**File 1: `.claude/agents/gsd-signal-collector.md`**

1. In Step 3 "Detect Signals", add a preliminary runtime/model detection substep at the beginning (before 3a):

```markdown
### 3.0 Runtime and Model Detection

Before detecting signals, determine the runtime and model context:

**Runtime detection:** Examine the path prefix in this agent spec file.
- ~/.claude/ paths -> runtime: claude-code
- ~/.config/opencode/ paths -> runtime: opencode
- ~/.gemini/ paths -> runtime: gemini-cli
- ~/.codex/ paths -> runtime: codex-cli

**Model detection:** Use self-knowledge of the current model name.
The executing model knows its own identifier (e.g., claude-opus-4-6,
claude-sonnet-4-20250514). Record this as the model value.

Store both values for inclusion in all signals created during this run.
If runtime cannot be determined, omit the field. If model cannot be
determined, omit the field.
```

2. In Step 8 "Write Signals", update item 6 to include the new fields:

Change:
```
6. Fill Phase 2 extension fields (polarity, source, occurrence_count, related_signals)
```
To:
```
6. Fill Phase 2 extension fields (polarity, source, occurrence_count, related_signals)
7. Fill runtime provenance fields: runtime (from step 3.0 detection), model (from step 3.0 detection). Omit either field if unknown.
```

And renumber the subsequent items (7 -> 8, 8 -> 9, 9 -> 10).

3. In Step 4 "Classify Signals", add after item 5 (tag determination):

```
6. Set `runtime` from step 3.0 detection (omit if unknown)
7. Set `model` from step 3.0 detection (omit if unknown)
```

**File 2: `get-shit-done/workflows/signal.md`**

1. In `<step name="extract_context">`, add after the project name derivation (item 2):

```markdown
4. **Runtime detection**: Examine the path prefix in this workflow file.
   - ~/.claude/ paths -> runtime: claude-code
   - ~/.config/opencode/ paths -> runtime: opencode
   - ~/.gemini/ paths -> runtime: gemini-cli
   - ~/.codex/ paths -> runtime: codex-cli
5. **Model detection**: Use self-knowledge of current model name (e.g.,
   claude-opus-4-6). If uncertain, use "unknown" or omit.
```

2. In `<step name="write_signal">`, update the frontmatter template to include the new fields. Add after `related_signals`:

```yaml
runtime: {detected-runtime}
model: {detected-model}
```

3. In `<step name="preview">`, add runtime and model to the preview display:

```
**Runtime:** {runtime} | **Model:** {model}
```

Add this line after the existing `**Phase:** {phase} | **Plan:** {plan}` line.

4. In the `<design_notes>` section, add a new bullet:
```
- **Runtime/model fields are best-effort:** The LLM detects runtime from path prefix and model from self-knowledge. If either is uncertain, the field is omitted rather than guessed incorrectly.
```
  </action>
  <verify>
```bash
# Verify runtime detection added to signal collector
grep -c 'Runtime detection' .claude/agents/gsd-signal-collector.md

# Verify runtime detection added to signal workflow
grep -c 'Runtime detection' get-shit-done/workflows/signal.md

# Verify model detection in both files
grep -c 'Model detection' .claude/agents/gsd-signal-collector.md
grep -c 'Model detection' get-shit-done/workflows/signal.md

# Verify runtime field in signal workflow template
grep -c 'runtime:.*detected' get-shit-done/workflows/signal.md
```

All should return >= 1.
  </verify>
  <done>
- Signal collector agent detects runtime from path prefix and model from self-knowledge
- Signal collector agent includes runtime/model in all signals it creates
- Manual signal workflow detects and includes runtime/model
- Manual signal preview shows runtime and model
- Both agents handle unknown runtime/model gracefully (omit field)
- Requirements covered: SIG-01 (runtime field populated), SIG-02 (model field populated)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add capability gap signal logging to execute-phase workflow</name>
  <files>
    get-shit-done/workflows/execute-phase.md
  </files>
  <action>
Update execute-phase.md to log capability gap signals when degraded execution occurs:

1. In the `<capability_check name="parallel_execution">` Else branch, AFTER the existing "Note to user" line, add capability gap signal logging:

```markdown
Else:
  Note to user (first occurrence only): "Note: Running sequentially -- this runtime doesn't support parallel agents."

  Log capability gap signal (trace severity, not persisted to KB):
  - signal_type: capability-gap
  - severity: trace
  - runtime: {detected from path prefix in this workflow file}
  - model: {self-reported model name}
  - description: "task_tool capability unavailable. Degraded from parallel wave execution to sequential plan execution."

  This signal appears in the signal collection report when /gsd:collect-signals
  runs for this phase. It is NOT written to the KB (trace signals are report-only
  per signal-detection.md Section 6).

  For each plan in execution order:
  [... rest of existing sequential execution logic unchanged ...]
```

2. In the `<capability_check name="hooks_support">` Else branch, AFTER the existing note, add:

```markdown
Else:
  Skip hook configuration.
  Note (first occurrence): "Update checks will run on GSD command invocation instead of session start."

  Log capability gap signal (trace severity, not persisted to KB):
  - signal_type: capability-gap
  - severity: trace
  - runtime: {detected from path prefix}
  - model: {self-reported model name}
  - description: "hooks capability unavailable. Update checks deferred to command invocation."
```

3. Add a brief comment block above the `<capability_adaptation>` section explaining the signal logging pattern:

```markdown
<!-- Capability gap signals are logged as trace severity during degraded execution.
     They appear in signal collection reports but are NOT persisted to the KB.
     See signal-detection.md Section 12 for the full specification. -->
```

4. Do NOT modify the existing execution logic, spawn patterns, checkpoint handling, or any other steps. Only add the signal logging to the Else branches.

**IMPORTANT:** The capability gap signals are conceptual -- they instruct the LLM executing this workflow to note the gap for the signal collection report. They are NOT programmatic signal file creation at this point. The signal collector agent (gsd-signal-collector) will detect these gaps from the execution artifacts (SUMMARY.md noting sequential execution) when it runs post-phase.

However, to make the gap DETECTABLE by the signal collector, ensure the "Note to user" lines are preserved (they end up in SUMMARY.md "Deviations from Plan" sections). The explicit "Log capability gap signal" instructions remind the executing LLM to mention the degradation in the summary.
  </action>
  <verify>
```bash
# Verify capability-gap signal logging in parallel execution check
grep -c 'capability-gap' get-shit-done/workflows/execute-phase.md

# Verify both capability checks have signal logging
grep -A5 'parallel_execution' get-shit-done/workflows/execute-phase.md | grep -c 'capability-gap'
grep -A5 'hooks_support' get-shit-done/workflows/execute-phase.md | grep -c 'capability-gap'

# Verify trace severity is specified
grep 'trace' get-shit-done/workflows/execute-phase.md | grep -c 'capability'
```
  </verify>
  <done>
- execute-phase.md parallel_execution Else branch logs capability-gap signal (trace)
- execute-phase.md hooks_support Else branch logs capability-gap signal (trace)
- Signal logging is trace severity (report-only, not KB-persisted)
- Existing execution logic unchanged (signal logging is additive)
- Requirements covered: SIG-04 (capability gap events logged as signals)
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the full signal enrichment requirement set:

1. **SIG-01** (runtime field): Signal template, collector, and manual workflow all include runtime field
2. **SIG-02** (model field): Signal template, collector, and manual workflow all include model field
3. **SIG-03** (template updated): Signal template has runtime/model fields and capability-gap type
4. **SIG-04** (capability gap logging): execute-phase.md logs capability-gap signals in Else branches

```bash
# SIG-01 + SIG-02: runtime and model in signal template
grep 'runtime:' .claude/agents/kb-templates/signal.md && echo "SIG-01: PASS"
grep 'model:' .claude/agents/kb-templates/signal.md && echo "SIG-02: PASS"

# SIG-03: capability-gap in template
grep 'capability-gap' .claude/agents/kb-templates/signal.md && echo "SIG-03: PASS"

# SIG-04: capability gap in execute-phase
grep 'capability-gap' get-shit-done/workflows/execute-phase.md && echo "SIG-04: PASS"

# Backward compat: no required fields added (runtime/model are optional)
grep -c 'Required.*runtime' .claude/agents/knowledge-store.md | grep '0' && echo "COMPAT: PASS"
```
</verification>

<success_criteria>
- Signal template has optional runtime: and model: fields
- knowledge-store.md schema documents runtime and model as optional signal extensions
- signal-detection.md has capability-gap type with trace severity and Section 12 documentation
- Signal collector agent detects and populates runtime/model from path prefix and self-knowledge
- Manual signal workflow detects and populates runtime/model
- execute-phase.md logs trace-severity capability-gap signals in both capability_check Else branches
- All existing signals remain valid (no schema breaking changes)
</success_criteria>

<output>
After completion, create `.planning/phases/16-cross-runtime-handoff-signal-enrichment/16-02-SUMMARY.md`
</output>
