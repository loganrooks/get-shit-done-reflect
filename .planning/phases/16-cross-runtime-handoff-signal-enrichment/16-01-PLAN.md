---
phase: 16-cross-runtime-handoff-signal-enrichment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/templates/continue-here.md
  - get-shit-done/workflows/pause-work.md
  - get-shit-done/workflows/resume-project.md
  - get-shit-done/references/continuation-format.md
autonomous: true

must_haves:
  truths:
    - "pause-work workflow generates .continue-here.md with zero runtime-specific command syntax in any section"
    - "resume-project workflow detects current runtime from path prefix and renders commands in correct syntax"
    - "continue-here.md template guides authors to write semantic state, not procedural commands"
    - "continuation-format.md documents that command rendering is runtime-adaptive"
    - "STATE.md template and all .planning/ templates contain no hardcoded /gsd: command references"
  artifacts:
    - path: "get-shit-done/templates/continue-here.md"
      provides: "Semantic-only continue-here template"
      contains: "next_action"
    - path: "get-shit-done/workflows/pause-work.md"
      provides: "Runtime-agnostic pause workflow"
      contains: "semantic"
    - path: "get-shit-done/workflows/resume-project.md"
      provides: "Runtime-detecting resume workflow"
      contains: "detect_runtime"
    - path: "get-shit-done/references/continuation-format.md"
      provides: "Runtime-adaptive continuation format reference"
      contains: "runtime"
  key_links:
    - from: "get-shit-done/workflows/pause-work.md"
      to: "get-shit-done/templates/continue-here.md"
      via: "template usage for .continue-here.md generation"
      pattern: "continue-here"
    - from: "get-shit-done/workflows/resume-project.md"
      to: ".continue-here.md files"
      via: "reads semantic state and renders runtime-appropriate commands"
      pattern: "detect_runtime"
---

<objective>
Make the pause/resume workflow runtime-agnostic so users can pause work in one runtime (e.g., Claude Code) and seamlessly resume in another (e.g., Codex CLI, OpenCode, Gemini CLI) with full state restoration.

Purpose: Currently, `.continue-here.md` files embed `/gsd:` command syntax (Claude Code specific), making them unresumable in other runtimes. This plan makes the handoff files store only semantic state, and the resume workflow detects the runtime and renders commands in the correct syntax at display time.

Output: Updated templates, workflows, and references that produce and consume runtime-agnostic handoff files.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-cross-runtime-handoff-signal-enrichment/16-RESEARCH.md

# Source files being modified
@get-shit-done/templates/continue-here.md
@get-shit-done/workflows/pause-work.md
@get-shit-done/workflows/resume-project.md
@get-shit-done/references/continuation-format.md
@get-shit-done/templates/state.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make continue-here template and pause-work workflow semantic-only</name>
  <files>
    get-shit-done/templates/continue-here.md
    get-shit-done/workflows/pause-work.md
  </files>
  <action>
Update TWO files to ensure `.continue-here.md` files never contain runtime-specific command syntax:

**File 1: `get-shit-done/templates/continue-here.md`**

1. In the `<next_action>` section example, replace `Start with: [specific action]` with a semantic example that describes WHAT to do, not HOW to invoke it. Example:

```markdown
<next_action>
Resume from task 3 of the current plan. The remaining work is
[describe what's left]. After completing this plan, proceed to
[next plan or phase transition].
</next_action>
```

2. In the `<guidelines>` section, add a new bullet:
```
- The <next_action> section must describe WHAT to do semantically, never HOW to invoke it.
  Do NOT include runtime-specific commands like /gsd:, /gsd-, or $gsd- in any section.
  Command rendering is the resume workflow's responsibility.
```

3. Do NOT change the YAML frontmatter fields or the other sections (current_state, completed_work, remaining_work, decisions_made, blockers, context) -- those are already semantic.

**File 2: `get-shit-done/workflows/pause-work.md`**

1. In the `<step name="write">` section: the `<next_action>` example currently says `Start with: [specific first action when resuming]`. Update it to a semantic example:

```markdown
<next_action>
Resume from: [specific task/plan]. Next step: [describe what to do].
After completing: [what comes next].
</next_action>
```

2. Add a note after the template block (before the `current-timestamp` instructions): "IMPORTANT: All sections must use semantic descriptions only. Never include runtime-specific command syntax (/gsd:, /gsd-, $gsd-) in the handoff file. The resume workflow handles command rendering."

3. In the `<step name="confirm">` section (line 110), change:
```
To resume: /gsd:resume-work
```
to:
```
To resume: start a new session and use the resume-work command.
```
This line is in the workflow SOURCE file. After installer transformation, it becomes a generic instruction. The user's runtime will have already been set up with the correct command syntax.

4. Do NOT change the step names, the detect/gather/commit steps, or the success_criteria section -- those are already fine.
  </action>
  <verify>
Grep both modified files for any remaining `/gsd:` references that would end up in generated `.continue-here.md` content. The pause-work.md source file may still contain `~/.claude/` path references (the installer transforms those) and `gsd-tools.js` references (also installer-transformed), which are fine. But the TEMPLATE content (what gets written to .continue-here.md) and the CONFIRMATION output must not contain `/gsd:` command syntax.

```bash
# Check that the template example sections have no /gsd: commands
grep -n '/gsd:' get-shit-done/templates/continue-here.md || echo "Template clean"

# Check that the pause-work confirmation no longer has /gsd:resume-work
grep -n '/gsd:resume-work' get-shit-done/workflows/pause-work.md || echo "Pause workflow clean"
```
  </verify>
  <done>
- continue-here.md template's next_action example is semantic (no command syntax)
- continue-here.md template's guidelines include the "no runtime-specific commands" rule
- pause-work.md's template content is semantic-only
- pause-work.md's confirmation output says "resume-work command" not "/gsd:resume-work"
- Requirements covered: HAND-02 (semantic state), HAND-01 (pause produces portable output)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add runtime detection to resume workflow and update continuation format</name>
  <files>
    get-shit-done/workflows/resume-project.md
    get-shit-done/references/continuation-format.md
  </files>
  <action>
Update TWO files to make the resume workflow runtime-aware and document the approach:

**File 1: `get-shit-done/workflows/resume-project.md`**

1. Add a new step AFTER `<step name="initialize">` and BEFORE `<step name="load_state">`. Name it `detect_runtime`:

```markdown
<step name="detect_runtime">
Detect which runtime this workflow is executing in by examining the path prefix
used in this file. The installer replaces ~/.claude/ with the target runtime's
path prefix during installation.

Runtime detection from path prefix:
- ~/.claude/ paths -> Claude Code (command prefix: /gsd:)
- ~/.config/opencode/ paths -> OpenCode (command prefix: /gsd-)
- ~/.gemini/ paths -> Gemini CLI (command prefix: /gsd:)
- ~/.codex/ paths -> Codex CLI (command prefix: $gsd-)

Store the detected command prefix for use when rendering command suggestions.
For example, if this file contains ~/.codex/ paths, the command prefix is $gsd-
and "plan-phase 3" renders as "$gsd-plan-phase 3".
</step>
```

2. In the `<step name="offer_options">` section, add a note at the top:

```markdown
**Command rendering:** When presenting command suggestions below, use the
command prefix detected in the detect_runtime step. All /gsd: references
in the examples below are SOURCE-format placeholders -- the installer
transforms them to the correct prefix for the installed runtime. When
displaying commands to the user (especially from .continue-here.md semantic
state), construct the command using the detected prefix.
```

3. In the `<step name="check_incomplete_work">` section, after the `.continue-here` handling block ("This is a mid-plan resumption point"), add:

```markdown
**Note:** The .continue-here.md file contains semantic state only (no command
syntax). When presenting resumption options, render commands using the detected
runtime prefix from detect_runtime step.
```

4. In `<step name="route_to_workflow">`, the examples show `/gsd:execute-phase` and `/gsd:plan-phase`. These are SOURCE-format -- they get transformed by the installer. Leave them as-is (the installer handles them). But add a note at the top of the step:

```markdown
**Note:** The command references below (e.g., /gsd:execute-phase) are in source
format. When this file is installed to a runtime, the installer transforms them
to the correct syntax. No additional runtime adaptation needed in this step.
```

5. Ensure backward compatibility: in `<step name="check_incomplete_work">`, the existing .continue-here.md files (phases 00 and 08) contain `/gsd:` command syntax in their `<next_action>` sections. The resume workflow should handle these gracefully. After the "Read the file for specific resumption context" bullet, add:

```markdown
- If <next_action> contains /gsd: or $gsd- command syntax (old format),
  display it as-is -- it may not match the current runtime but provides
  useful context. New-format files have semantic-only next_action.
```

**File 2: `get-shit-done/references/continuation-format.md`**

1. After the "## Format Rules" section (before "## Variants"), add a new section:

```markdown
## Runtime Adaptation

Command references in continuation format are written in source syntax (/gsd:command).
The GSD installer transforms these to the correct runtime syntax during installation:

| Runtime | Command Syntax | Example |
|---------|---------------|---------|
| Claude Code | /gsd:command | /gsd:plan-phase 3 |
| OpenCode | /gsd-command | /gsd-plan-phase 3 |
| Gemini CLI | /gsd:command | /gsd:plan-phase 3 |
| Codex CLI | $gsd-command | $gsd-plan-phase 3 |

Workflow authors write commands using /gsd: source syntax. No conditional
logic is needed -- the installer handles per-runtime transformation.

The one exception is `.continue-here.md` files, which must contain NO command
syntax at all (semantic state only). The resume-project.md workflow renders
runtime-appropriate commands when presenting resumption options.
```

2. Do NOT modify the existing variant examples -- they are source-format and the installer transforms them. Just add the documentation section.
  </action>
  <verify>
```bash
# Verify detect_runtime step was added to resume-project.md
grep -c 'detect_runtime' get-shit-done/workflows/resume-project.md

# Verify the runtime adaptation section was added to continuation-format.md
grep -c 'Runtime Adaptation' get-shit-done/references/continuation-format.md

# Verify backward compat note for old-format .continue-here.md files
grep -c 'old format' get-shit-done/workflows/resume-project.md
```

All three should return >= 1.
  </verify>
  <done>
- resume-project.md has a detect_runtime step that maps path prefix to command syntax
- resume-project.md handles old-format .continue-here.md files gracefully
- resume-project.md notes that command rendering uses detected prefix
- continuation-format.md documents the runtime adaptation model (installer transforms + semantic handoff files)
- Requirements covered: HAND-03 (runtime detection + rendering), HAND-01 (cross-runtime resume)
  </done>
</task>

<task type="auto">
  <name>Task 3: Audit templates for HAND-04 compliance (no hardcoded runtime commands)</name>
  <files>
    get-shit-done/templates/state.md
  </files>
  <action>
Audit all GSD templates and the STATE.md template for hardcoded `/gsd:` command references that would end up in generated `.planning/` files:

1. **`get-shit-done/templates/state.md`**: Read the file and check for any `/gsd:` command references. Currently this file contains no command references -- it uses descriptive text like "Path to .continue-here*.md" and references to PROJECT.md. Verify this is still the case. If any `/gsd:` references exist, replace with semantic descriptions.

2. **Scan all templates**: Run a grep across `get-shit-done/templates/` for `/gsd:` references:

```bash
grep -rn '/gsd:' get-shit-done/templates/ || echo "All templates clean"
```

Any hits in template CONTENT (not in documentation/guidelines about commands) need to be made semantic.

3. **Scan .planning/ generated files for hardcoded paths**: Run a targeted check on STATE.md template and any other templates that produce `.planning/` content:

```bash
grep -rn '/gsd:' get-shit-done/templates/*.md | grep -v 'continuation-format' || echo "Clean"
```

The continuation-format.md is a REFERENCE doc (not a template that generates .planning/ files), so hits there are expected and fine.

4. If the state.md template is already clean (expected based on current content), no modifications needed -- just document the audit result in the summary. If any issues found, fix them by replacing command syntax with semantic descriptions.

**IMPORTANT:** This task is an AUDIT. The state.md template currently appears clean. If it IS clean, the task is verifying compliance, not modifying files. Only modify if issues are found.
  </action>
  <verify>
```bash
# Verify no /gsd: in state template
grep -c '/gsd:' get-shit-done/templates/state.md && echo "FAIL: state template has commands" || echo "PASS: state template clean"

# Verify no /gsd: in summary template
grep -c '/gsd:' get-shit-done/templates/summary-standard.md 2>/dev/null && echo "WARN: summary template has commands" || echo "PASS: summary template clean"

# Broad template scan (excluding continuation-format which is a reference doc, not a generator)
grep -rn '/gsd:' get-shit-done/templates/ | grep -v continuation-format | wc -l
```

The last command should return 0 (no template content generates /gsd: commands in .planning/ files).
  </verify>
  <done>
- All templates in get-shit-done/templates/ that generate .planning/ content are free of hardcoded /gsd: command syntax
- STATE.md template confirmed clean (or fixed if issues found)
- Audit documented for HAND-04 compliance
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the full handoff requirement set:

1. **HAND-01** (cross-runtime pause/resume): pause-work.md produces semantic .continue-here.md, resume-project.md detects runtime and renders commands
2. **HAND-02** (semantic state): continue-here.md template and pause-work.md workflow produce no command syntax
3. **HAND-03** (runtime detection): resume-project.md has detect_runtime step with path-prefix-to-command-prefix mapping
4. **HAND-04** (no hardcoded paths): template audit confirms all .planning/ generators are clean

```bash
# Cross-cutting verification: no /gsd: in template content that generates handoff files
grep -rn '/gsd:' get-shit-done/templates/continue-here.md && echo "FAIL" || echo "PASS: HAND-02"
grep '/gsd:resume-work' get-shit-done/workflows/pause-work.md && echo "FAIL" || echo "PASS: HAND-01"
grep 'detect_runtime' get-shit-done/workflows/resume-project.md && echo "PASS: HAND-03" || echo "FAIL"
```
</verification>

<success_criteria>
- continue-here.md template produces semantic-only handoff files (zero command syntax)
- pause-work.md generates semantic next_action and generic resume confirmation
- resume-project.md detects runtime from path prefix and renders correct command syntax
- continuation-format.md documents the runtime adaptation model
- All .planning/ template generators are free of hardcoded /gsd: commands
- Backward compatible with existing .continue-here.md files (phases 00, 08)
</success_criteria>

<output>
After completion, create `.planning/phases/16-cross-runtime-handoff-signal-enrichment/16-01-SUMMARY.md`
</output>
