---
phase: 24-manifest-driven-config-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/bin/gsd-tools.js
  - get-shit-done/bin/gsd-tools.test.js
  - get-shit-done/feature-manifest.json
autonomous: true

must_haves:
  truths:
    - "manifest apply-migration fills missing feature sections with manifest defaults"
    - "manifest apply-migration adds missing fields to existing feature sections"
    - "manifest apply-migration coerces string 'true' to boolean true and string numbers to numbers"
    - "manifest apply-migration updates manifest_version in config.json"
    - "atomicWriteJson writes to .tmp then renames (never direct writeFileSync)"
    - "KNOWN_TOP_LEVEL_KEYS is a single module-level constant referenced by diff-config and validate"
    - "feature-manifest.json has auto_detect rules for devops ci_provider, deploy_target, and commit_convention"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "coerceValue, atomicWriteJson, cmdManifestApplyMigration helpers and KNOWN_TOP_LEVEL_KEYS constant"
      contains: "KNOWN_TOP_LEVEL_KEYS"
    - path: "get-shit-done/bin/gsd-tools.test.js"
      provides: "Tests for apply-migration command and coerceValue behavior"
      contains: "apply-migration"
    - path: "get-shit-done/feature-manifest.json"
      provides: "auto_detect rules for devops features"
      contains: "auto_detect"
  key_links:
    - from: "cmdManifestApplyMigration"
      to: "coerceValue"
      via: "function call during field iteration"
      pattern: "coerceValue\\("
    - from: "cmdManifestApplyMigration"
      to: "atomicWriteJson"
      via: "atomic config write after changes"
      pattern: "atomicWriteJson\\("
    - from: "cmdManifestDiffConfig"
      to: "KNOWN_TOP_LEVEL_KEYS"
      via: "module-level constant reference"
      pattern: "KNOWN_TOP_LEVEL_KEYS"
---

<objective>
Build the core migration engine: helpers (coerceValue, atomicWriteJson, KNOWN_TOP_LEVEL_KEYS extraction) and the `manifest apply-migration` command that reads the manifest, diffs against config, applies missing features/fields with defaults, coerces types, and writes atomically.

Purpose: This is the write-side counterpart to Phase 23's read-side tooling. The apply-migration command is the single function that upgrade-project, new-project, and update workflows will all call to fill config gaps.

Output: Working apply-migration command with tests, coerceValue helper, atomicWriteJson helper, KNOWN_TOP_LEVEL_KEYS deduplication, and devops auto_detect manifest extension.

**Approach: TDD** — write all tests first (Task 1), then implement to make them pass (Task 2).
</objective>

<execution_context>
@/Users/rookslog/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rookslog/.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-manifest-driven-config-migration/24-RESEARCH.md
@.planning/phases/23-feature-manifest-foundation/23-01-SUMMARY.md
@.planning/phases/23-feature-manifest-foundation/23-02-SUMMARY.md
@get-shit-done/bin/gsd-tools.js
@get-shit-done/bin/gsd-tools.test.js
@get-shit-done/feature-manifest.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for manifest apply-migration command</name>
  <files>
    get-shit-done/bin/gsd-tools.test.js
  </files>
  <action>
**TDD RED phase:** Write all tests first. They WILL fail because `manifest apply-migration` does not exist yet. That is expected and correct.

Add a new `describe('manifest apply-migration', ...)` block after the existing manifest test blocks. Use the existing `createManifestTestEnv` helper pattern. Tests needed:

1. **adds missing feature sections with defaults**: Create config missing health_check, run apply-migration, verify health_check section added with all schema defaults
2. **adds missing fields to existing sections**: Create config with health_check but missing blocking_checks, verify field added with default
3. **coerces string boolean to boolean**: Create config with `health_check.blocking_checks: "true"`, verify coerced to `true`
4. **coerces string number to number**: Create config with `health_check.stale_threshold_days: "7"`, verify coerced to `7`
5. **updates manifest_version**: Create config with manifest_version: 0, verify updated to manifest's manifest_version
6. **no changes when config is complete**: Create config with all features and correct types, verify `total_changes: 0`
7. **preserves existing values**: Create config with `health_check.frequency: "every-phase"`, run apply-migration, verify frequency still "every-phase" (not overwritten with default)
8. **atomic write creates no .tmp residue**: After successful apply-migration, verify no .tmp file remains
9. **reports all change types in output**: Run on config missing one feature + one field + one type mismatch, verify changes array contains all three types

For each test, use the pattern from existing manifest tests: create temp dir, write manifest + config, run the command via `execSync('node ... manifest apply-migration --raw')`, parse JSON output, assert.

**Important:** After writing the tests, run the test suite. The 9 new tests MUST fail (the command does not exist yet). Existing tests MUST still pass. This confirms the tests are correctly written and the red phase is complete.
  </action>
  <verify>
1. Run: `node --test get-shit-done/bin/gsd-tools.test.js 2>&1 | tail -5` -- 9 new apply-migration tests fail, all existing tests pass
2. `grep -c 'apply-migration' get-shit-done/bin/gsd-tools.test.js` returns 10+ (test describe + individual tests)
  </verify>
  <done>
9 apply-migration tests written and confirmed failing. Each test specifies exact expected behavior: missing features filled, missing fields added, type coercion, manifest_version update, value preservation, atomic write, change reporting. Existing test suite still passes. TDD red phase complete.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement apply-migration command + helpers + manifest extension to make all tests pass</name>
  <files>
    get-shit-done/bin/gsd-tools.js
    get-shit-done/feature-manifest.json
  </files>
  <action>
**TDD GREEN phase:** Implement the minimum code to make all 9 tests pass.

**Part A: Extract KNOWN_TOP_LEVEL_KEYS constant**

The `knownTopLevel` set is duplicated at two locations in gsd-tools.js:
1. Inside `cmdManifestDiffConfig` (around line 4282)
2. Inside `cmdManifestValidate` (around line 4397)

Extract into a single module-level constant near the top of the file (after the helper functions, before the command functions -- around line 530):

```javascript
const KNOWN_TOP_LEVEL_KEYS = new Set([
  'mode', 'depth', 'model_profile', 'commit_docs', 'search_gitignored',
  'branching_strategy', 'phase_branch_template', 'milestone_branch_template',
  'workflow', 'planning', 'parallelization', 'gates', 'safety',
  'gsd_reflect_version', 'manifest_version', 'brave_search',
]);
```

Replace both inline `knownTopLevel` usages with the module-level `KNOWN_TOP_LEVEL_KEYS`. In `cmdManifestDiffConfig`, remove the local `const knownTopLevel = new Set([...])` and change `!knownTopLevel.has(key)` to `!KNOWN_TOP_LEVEL_KEYS.has(key)`. Do the same in `cmdManifestValidate`.

**Part B: Add coerceValue helper**

Add near other helper functions (after `validateFieldEnum`, around line 528):

```javascript
function coerceValue(value, schema) {
  const target = schema.type;
  if (target === 'boolean') {
    if (value === 'true') return true;
    if (value === 'false') return false;
  }
  if (target === 'number') {
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (trimmed !== '' && !isNaN(trimmed)) return Number(trimmed);
    }
  }
  if (target === 'string') {
    if (typeof value === 'boolean') return String(value);
    if (typeof value === 'number') return String(value);
  }
  if (target === 'array') {
    if (!Array.isArray(value) && value !== null && value !== undefined) {
      return [value];
    }
  }
  return value;
}
```

Do NOT coerce numbers to booleans (0 could mean "zero days threshold", not "false").

**Part C: Add atomicWriteJson helper**

Add near other helper functions:

```javascript
function atomicWriteJson(filePath, data) {
  const tmpPath = filePath + '.tmp';
  const content = JSON.stringify(data, null, 2) + '\n';
  fs.writeFileSync(tmpPath, content, 'utf-8');
  fs.renameSync(tmpPath, filePath);
}
```

The .tmp file MUST be in the same directory as the target (not os.tmpdir()) to guarantee same-filesystem for atomic rename.

**Part D: Add cmdManifestApplyMigration function**

Add before the CLI Router section (before `async function main()`):

```javascript
function cmdManifestApplyMigration(cwd, raw) {
  const manifest = loadManifest(cwd);
  if (!manifest) { error('Manifest not found. Is GSD installed?'); }
  const configPath = path.join(cwd, '.planning', 'config.json');
  const config = loadProjectConfig(cwd);
  if (!config) { error('No .planning/config.json found. Run /gsd:new-project first.'); }

  const changes = [];

  for (const [featureName, featureDef] of Object.entries(manifest.features)) {
    if (featureDef.scope !== 'project' || !featureDef.config_key) continue;
    const key = featureDef.config_key;

    if (!config[key]) {
      // Add entire missing feature section with defaults
      config[key] = {};
      for (const [field, schema] of Object.entries(featureDef.schema)) {
        config[key][field] = schema.default;
      }
      changes.push({
        type: 'feature_added',
        feature: featureName,
        config_key: key,
        fields_added: Object.keys(featureDef.schema),
      });
    } else {
      // Add missing fields and coerce types in existing section
      for (const [field, schema] of Object.entries(featureDef.schema)) {
        if (config[key][field] === undefined) {
          config[key][field] = schema.default;
          changes.push({
            type: 'field_added',
            feature: featureName,
            field,
            default_value: schema.default,
          });
        } else {
          const coerced = coerceValue(config[key][field], schema);
          if (coerced !== config[key][field]) {
            changes.push({
              type: 'type_coerced',
              feature: featureName,
              field,
              from: config[key][field],
              to: coerced,
            });
            config[key][field] = coerced;
          }
        }
      }
    }
  }

  // Update manifest_version
  if (config.manifest_version !== manifest.manifest_version) {
    changes.push({
      type: 'manifest_version_updated',
      from: config.manifest_version || null,
      to: manifest.manifest_version,
    });
    config.manifest_version = manifest.manifest_version;
  }

  if (changes.length > 0) {
    atomicWriteJson(configPath, config);
  }

  output({ changes, total_changes: changes.length }, raw);
}
```

**Part E: Wire into CLI router**

In the `case 'manifest':` block, add an `else if` for apply-migration:

```javascript
} else if (subcommand === 'apply-migration') {
  cmdManifestApplyMigration(cwd, raw);
}
```

Also update the error message to include apply-migration in the available subcommands list.

**Part F: Extend feature-manifest.json with devops auto_detect**

Add an `auto_detect` section to the `devops` feature in feature-manifest.json, structured like the existing release.auto_detect:

```json
"auto_detect": {
  "ci_provider": [
    { "check": "dir_exists", "path": ".github/workflows", "value": "github-actions" },
    { "check": "file_exists", "path": ".gitlab-ci.yml", "value": "gitlab-ci" },
    { "check": "file_exists", "path": ".circleci/config.yml", "value": "circleci" },
    { "check": "file_exists", "path": "Jenkinsfile", "value": "jenkins" },
    { "check": "file_exists", "path": "bitbucket-pipelines.yml", "value": "bitbucket-pipelines" }
  ],
  "deploy_target": [
    { "check": "file_exists", "path": "vercel.json", "value": "vercel" },
    { "check": "dir_exists", "path": ".vercel", "value": "vercel" },
    { "check": "file_exists", "path": "Dockerfile", "value": "docker" },
    { "check": "file_exists", "path": "fly.toml", "value": "fly-io" },
    { "check": "file_exists", "path": "netlify.toml", "value": "netlify" }
  ],
  "commit_convention": [
    { "check": "git_log_pattern", "pattern": "^(feat|fix|chore|docs|style|refactor|test|ci|build|perf)\\(", "threshold": 0.5, "value": "conventional" }
  ]
}
```

Place this within the devops feature object, at the same level as `schema` and `init_prompts`.

**Part G: Run tests — all 9 must now pass**

Run the full test suite. All 9 new apply-migration tests must pass. All existing tests must still pass. If any test fails, fix the implementation (not the test) until green.
  </action>
  <verify>
1. Run `node --test get-shit-done/bin/gsd-tools.test.js` -- ALL tests pass (0 failures), including the 9 new apply-migration tests
2. Run `grep -c 'knownTopLevel' get-shit-done/bin/gsd-tools.js` -- should return 0 (no more local `knownTopLevel` variables)
3. Run `grep -c 'KNOWN_TOP_LEVEL_KEYS' get-shit-done/bin/gsd-tools.js` -- should return 3+ (1 declaration, 2+ usages)
4. Run `node get-shit-done/bin/gsd-tools.js manifest diff-config --raw` to confirm existing manifest commands still work with the extracted constant
5. Run `node get-shit-done/bin/gsd-tools.js manifest validate --raw` to confirm validate still works
6. Run `node -e "const m = JSON.parse(require('fs').readFileSync('get-shit-done/feature-manifest.json','utf-8')); console.log(Object.keys(m.features.devops.auto_detect))"` -- should show ci_provider, deploy_target, commit_convention
7. Run `node get-shit-done/bin/gsd-tools.js manifest apply-migration --raw` from the project root -- should output JSON with changes (or total_changes: 0 if config is up to date)
8. Verify no .tmp file: `ls .planning/config.json.tmp 2>/dev/null` -- should not exist
  </verify>
  <done>
TDD green phase complete. All 9 apply-migration tests pass. `manifest apply-migration` command fills missing features with defaults, adds missing fields, coerces types, updates manifest_version, writes atomically, and reports all changes. KNOWN_TOP_LEVEL_KEYS deduplicated. coerceValue and atomicWriteJson helpers working. Devops auto_detect rules added to manifest. No regressions in existing tests.
  </done>
</task>

</tasks>

<verification>
1. Existing test suite passes: `node --test get-shit-done/bin/gsd-tools.test.js` -- no regressions in existing manifest diff-config, validate, get-prompts tests
2. KNOWN_TOP_LEVEL_KEYS deduplication: `grep -c 'knownTopLevel' get-shit-done/bin/gsd-tools.js` returns 0
3. apply-migration works on real project config: `node get-shit-done/bin/gsd-tools.js manifest apply-migration --raw` produces valid JSON output
4. feature-manifest.json is valid JSON: `node -e "JSON.parse(require('fs').readFileSync('get-shit-done/feature-manifest.json','utf-8'))"`
</verification>

<success_criteria>
- TDD: Tests written BEFORE implementation, confirmed failing, then implementation makes them pass
- coerceValue correctly handles: string->boolean, string->number, number->string, boolean->string, single-value->array
- atomicWriteJson uses write-tmp-then-rename pattern (never direct writeFileSync for config)
- KNOWN_TOP_LEVEL_KEYS is a single constant (no duplicates)
- apply-migration fills missing features, adds missing fields, coerces types, updates manifest_version
- apply-migration never modifies existing correctly-typed values
- 9+ tests pass for apply-migration
- devops auto_detect rules cover CI, deploy, and commit convention
</success_criteria>

<output>
After completion, create `.planning/phases/24-manifest-driven-config-migration/24-01-SUMMARY.md`
</output>
