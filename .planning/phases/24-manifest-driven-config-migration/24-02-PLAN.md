---
phase: 24-manifest-driven-config-migration
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - get-shit-done/bin/gsd-tools.js
  - get-shit-done/bin/gsd-tools.test.js
autonomous: true

must_haves:
  truths:
    - "manifest log-migration appends a timestamped entry to .planning/migration-log.md"
    - "manifest log-migration creates migration-log.md with header if file does not exist"
    - "manifest log-migration formats feature_added, field_added, type_coerced, and manifest_version_updated change types"
    - "manifest auto-detect returns detected CI provider from .github/workflows directory"
    - "manifest auto-detect returns detected deploy target from config files (vercel.json, Dockerfile, etc.)"
    - "manifest auto-detect handles git_log_pattern check for commit convention"
    - "manifest auto-detect returns empty detected object for features with no auto_detect rules"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "cmdManifestLogMigration, cmdManifestAutoDetect, formatMigrationEntry functions"
      contains: "cmdManifestLogMigration"
    - path: "get-shit-done/bin/gsd-tools.test.js"
      provides: "Tests for log-migration and auto-detect commands"
      contains: "log-migration"
  key_links:
    - from: "cmdManifestLogMigration"
      to: "formatMigrationEntry"
      via: "function call for consistent entry formatting"
      pattern: "formatMigrationEntry\\("
    - from: "cmdManifestAutoDetect"
      to: "feature-manifest.json auto_detect"
      via: "loadManifest().features[feature].auto_detect"
      pattern: "auto_detect"
---

<objective>
Add the migration logging command (`manifest log-migration`) and the auto-detection command (`manifest auto-detect`) to gsd-tools.js, with comprehensive tests.

Purpose: log-migration provides the audit trail required by MIGR-05 (every config change is logged). auto-detect enables manifest-driven filesystem detection (replacing hardcoded bash scripts in new-project.md) for MIGR-02.

Output: Two new manifest subcommands with tests, completing the write-side tooling needed for Plan 03's workflow integration.
</objective>

<execution_context>
@/Users/rookslog/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rookslog/.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-manifest-driven-config-migration/24-RESEARCH.md
@.planning/phases/24-manifest-driven-config-migration/24-01-SUMMARY.md
@get-shit-done/bin/gsd-tools.js
@get-shit-done/bin/gsd-tools.test.js
@get-shit-done/feature-manifest.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add manifest log-migration command with tests</name>
  <files>
    get-shit-done/bin/gsd-tools.js
    get-shit-done/bin/gsd-tools.test.js
  </files>
  <action>
**Part A: Add formatMigrationEntry helper to gsd-tools.js**

Add near other helper functions (close to coerceValue/atomicWriteJson from Plan 01):

```javascript
function formatMigrationEntry(fromVersion, toVersion, timestamp, changes) {
  let entry = `## ${fromVersion} -> ${toVersion} (${timestamp})\n\n`;
  entry += `### Changes Applied\n`;
  for (const change of changes) {
    if (change.type === 'feature_added') {
      entry += `- Added \`${change.config_key}\` section`;
      if (change.fields_added) {
        entry += ` (${change.fields_added.join(', ')})`;
      }
      entry += '\n';
    } else if (change.type === 'field_added') {
      entry += `- Added \`${change.feature}.${change.field}\`: ${JSON.stringify(change.default_value)}\n`;
    } else if (change.type === 'type_coerced') {
      entry += `- Coerced \`${change.feature}.${change.field}\` from ${JSON.stringify(change.from)} to ${JSON.stringify(change.to)}\n`;
    } else if (change.type === 'manifest_version_updated') {
      entry += `- Updated manifest_version: ${change.from} -> ${change.to}\n`;
    }
  }
  return entry;
}
```

**Part B: Add cmdManifestLogMigration function**

```javascript
function cmdManifestLogMigration(cwd, raw) {
  const args = process.argv.slice(2);
  const fromIdx = args.indexOf('--from');
  const toIdx = args.indexOf('--to');
  const changesIdx = args.indexOf('--changes');

  if (fromIdx === -1 || toIdx === -1 || changesIdx === -1) {
    error('Usage: manifest log-migration --from <version> --to <version> --changes <json>');
  }

  const fromVersion = args[fromIdx + 1];
  const toVersion = args[toIdx + 1];
  let changes;
  try {
    changes = JSON.parse(args[changesIdx + 1]);
  } catch (e) {
    error('Invalid JSON for --changes: ' + e.message);
  }

  const logPath = path.join(cwd, '.planning', 'migration-log.md');
  const timestamp = new Date().toISOString();
  const entry = formatMigrationEntry(fromVersion, toVersion, timestamp, changes);

  const header = '# Migration Log\n\nTracks version upgrades applied to this project.\n';
  const footer = '\n---\n\n*Log is append-only.*\n';

  if (!fs.existsSync(logPath)) {
    fs.writeFileSync(logPath, header + '\n' + entry + footer, 'utf-8');
  } else {
    const existing = fs.readFileSync(logPath, 'utf-8');
    // Insert new entry after the header block (first double newline after "# Migration Log")
    const headerMarker = '# Migration Log';
    const headerPos = existing.indexOf(headerMarker);
    if (headerPos === -1) {
      // No header found, prepend
      fs.writeFileSync(logPath, header + '\n' + entry + '\n---\n\n' + existing, 'utf-8');
    } else {
      const headerEnd = existing.indexOf('\n\n', headerPos + headerMarker.length);
      if (headerEnd === -1) {
        fs.writeFileSync(logPath, existing + '\n\n' + entry + footer, 'utf-8');
      } else {
        const before = existing.substring(0, headerEnd + 2);
        const after = existing.substring(headerEnd + 2);
        fs.writeFileSync(logPath, before + entry + '\n---\n\n' + after, 'utf-8');
      }
    }
  }

  output({ logged: true, path: '.planning/migration-log.md', timestamp }, raw);
}
```

**Part C: Wire into CLI router**

In the `case 'manifest':` block, add:

```javascript
} else if (subcommand === 'log-migration') {
  cmdManifestLogMigration(cwd, raw);
}
```

Update the error message to include log-migration in available subcommands.

**Part D: Add tests**

Add `describe('manifest log-migration', ...)` block with these tests:

1. **creates migration-log.md when it does not exist**: Run log-migration in temp dir with no existing log, verify file created with header + entry
2. **appends entry to existing migration-log.md**: Create log with header + existing entry, run log-migration, verify new entry prepended after header (before old entry)
3. **formats feature_added changes correctly**: Pass changes with type: feature_added, verify entry contains `Added \`config_key\` section (fields)`
4. **formats field_added changes correctly**: Pass changes with type: field_added, verify entry format
5. **formats type_coerced changes correctly**: Pass changes with type: type_coerced, verify from/to values shown
6. **formats manifest_version_updated correctly**: Pass changes with type: manifest_version_updated, verify version numbers shown
7. **reports logged: true with path**: Verify JSON output has `logged: true` and path field

For each test, create a temp dir with `.planning/` subdirectory, run the command via execSync, then read the resulting migration-log.md to verify content. Pass --changes as a JSON string argument.

**Important:** When passing JSON via command line, the changes JSON must be properly escaped/quoted for the shell. Use `JSON.stringify(changes)` wrapped in single quotes.
  </action>
  <verify>
1. Run in temp dir: `node get-shit-done/bin/gsd-tools.js manifest log-migration --from 1.12.0 --to 1.15.0 --changes '[{"type":"feature_added","config_key":"release","fields_added":["version_file","changelog"]}]' --raw` -- should output `{"logged":true,...}`
2. Run tests: `node --test get-shit-done/bin/gsd-tools.test.js 2>&1 | grep -E "(log-migration|pass|fail)"` -- all log-migration tests pass
  </verify>
  <done>
`manifest log-migration` creates or appends to migration-log.md with correctly formatted entries for all change types (feature_added, field_added, type_coerced, manifest_version_updated). 7+ tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add manifest auto-detect command with tests</name>
  <files>
    get-shit-done/bin/gsd-tools.js
    get-shit-done/bin/gsd-tools.test.js
  </files>
  <action>
**Part A: Add cmdManifestAutoDetect function to gsd-tools.js**

```javascript
function cmdManifestAutoDetect(cwd, raw) {
  const args = process.argv.slice(2);
  const feature = args[2]; // manifest auto-detect <feature>

  const manifest = loadManifest(cwd);
  if (!manifest) { error('Manifest not found. Is GSD installed?'); }
  if (!feature) { error('Feature name required. Usage: manifest auto-detect <feature>'); }
  const featureDef = manifest.features[feature];
  if (!featureDef) {
    error(`Unknown feature: ${feature}. Available: ${Object.keys(manifest.features).join(', ')}`);
  }
  if (!featureDef.auto_detect) {
    output({ feature, detected: {} }, raw);
    return;
  }

  const detected = {};
  for (const [field, rules] of Object.entries(featureDef.auto_detect)) {
    for (const rule of rules) {
      if (rule.check === 'file_exists') {
        const fullPath = path.join(cwd, rule.path);
        if (fs.existsSync(fullPath) && !fs.statSync(fullPath).isDirectory()) {
          detected[field] = rule.value;
          break;
        }
      } else if (rule.check === 'dir_exists') {
        const fullPath = path.join(cwd, rule.path);
        if (fs.existsSync(fullPath) && fs.statSync(fullPath).isDirectory()) {
          detected[field] = rule.value;
          break;
        }
      } else if (rule.check === 'git_log_pattern') {
        try {
          const { execSync } = require('child_process');
          const logs = execSync('git log --oneline -20 2>/dev/null', { cwd, encoding: 'utf-8' }).trim();
          const lines = logs.split('\n').filter(l => l.length > 0);
          if (lines.length > 0) {
            const regex = new RegExp(rule.pattern);
            const matches = lines.filter(l => regex.test(l.replace(/^[a-f0-9]+ /, '')));
            if (matches.length / lines.length >= (rule.threshold || 0.5)) {
              detected[field] = rule.value;
            }
          }
        } catch (e) {
          // git not available or not a git repo -- skip
        }
        break; // Only one git_log_pattern rule per field
      }
    }
  }

  output({ feature, detected }, raw);
}
```

**Note:** The `require('child_process')` for execSync -- check if it's already imported at the top of gsd-tools.js. If not, add it. If `execSync` is already available (check the file's imports), use the existing reference.

**Part B: Wire into CLI router**

In the `case 'manifest':` block, add:

```javascript
} else if (subcommand === 'auto-detect') {
  cmdManifestAutoDetect(cwd, raw);
}
```

Update the error message to include auto-detect in available subcommands.

**Part C: Add tests**

Add `describe('manifest auto-detect', ...)` block with these tests:

1. **detects CI provider from .github/workflows directory**: Create temp dir with `.github/workflows/` directory, write manifest with devops auto_detect, run `manifest auto-detect devops --raw`, verify `detected.ci_provider === "github-actions"`
2. **detects deploy target from Dockerfile**: Create temp dir with `Dockerfile`, verify `detected.deploy_target === "docker"`
3. **detects multiple fields simultaneously**: Create temp dir with both `.github/workflows/` and `Dockerfile`, verify both ci_provider and deploy_target detected
4. **returns empty detected for feature with no auto_detect rules**: Run `manifest auto-detect health_check --raw` (health_check has no auto_detect), verify `detected: {}`
5. **detects version_file from package.json**: Create temp dir with `package.json`, run `manifest auto-detect release --raw`, verify `detected.version_file === "package.json"`
6. **file_exists does not match directories**: Create a directory named `Dockerfile` (not a file), verify deploy_target is NOT detected
7. **dir_exists does not match files**: Create a file named `.github/workflows` (not a directory), verify ci_provider is NOT detected

For each test, create isolated temp dirs. Write the manifest JSON to the expected location (use createManifestTestEnv pattern or create `.claude/get-shit-done/feature-manifest.json` in the temp dir). Create the detection target files/directories as needed.

**Note on git_log_pattern tests:** Testing git_log_pattern requires a git repo with commits, which is complex for unit tests. Include one test that creates a temp git repo with conventional commits and verifies commit_convention detection. If this is too brittle, mark it as a separate integration test or skip with a comment explaining why.
  </action>
  <verify>
1. Run from project root: `node get-shit-done/bin/gsd-tools.js manifest auto-detect devops --raw` -- should detect github-actions (this project has .github/workflows)
2. Run from project root: `node get-shit-done/bin/gsd-tools.js manifest auto-detect release --raw` -- should detect package.json
3. Run from project root: `node get-shit-done/bin/gsd-tools.js manifest auto-detect health_check --raw` -- should show `detected: {}`
4. Run tests: `node --test get-shit-done/bin/gsd-tools.test.js 2>&1 | grep -E "(auto-detect|pass|fail)"` -- all auto-detect tests pass
  </verify>
  <done>
`manifest auto-detect` runs filesystem and git checks from the manifest's auto_detect rules and returns detected values. Handles file_exists, dir_exists, and git_log_pattern check types. 7+ tests pass covering detection, non-detection, multi-field, and edge cases.
  </done>
</task>

</tasks>

<verification>
1. Full test suite passes: `node --test get-shit-done/bin/gsd-tools.test.js` -- no regressions
2. All manifest subcommands work: diff-config, validate, get-prompts, apply-migration, log-migration, auto-detect
3. Auto-detect on this project: `node get-shit-done/bin/gsd-tools.js manifest auto-detect devops --raw` returns github-actions
4. Log-migration produces valid markdown: run command, read migration-log.md, verify structure
</verification>

<success_criteria>
- log-migration creates migration-log.md if absent, appends entries if present
- log-migration formats all 4 change types (feature_added, field_added, type_coerced, manifest_version_updated)
- auto-detect runs file_exists, dir_exists, and git_log_pattern checks
- auto-detect returns empty detected object for features without auto_detect rules
- 14+ new tests pass (7+ per command)
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/24-manifest-driven-config-migration/24-02-SUMMARY.md`
</output>
