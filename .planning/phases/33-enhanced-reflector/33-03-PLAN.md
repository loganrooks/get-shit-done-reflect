---
phase: 33-enhanced-reflector
plan: 03
type: execute
wave: 2
depends_on: ["33-01", "33-02"]
files_modified:
  - agents/gsd-reflector.md
autonomous: true

must_haves:
  truths:
    - "Reflector reads lifecycle_state from signals and adjusts analysis by state (detected=full analysis, triaged=skip triage, remediated=lower weight, verified=positive only, invalidated=exclude)"
    - "Reflector computes confidence-weighted scores for clusters using the formula from reflection-patterns.md"
    - "Reflector seeks counter-evidence using index metadata first, reading full files only for confirmed candidates (bounded to 3 per pattern)"
    - "Reflector generates triage proposals with cluster-level decisions (address/dismiss/defer/investigate)"
    - "Reflector generates remediation suggestions for triaged address clusters"
    - "Reflector distills lessons with evidence_snapshots field"
    - "Reflector flags low-confidence and investigate patterns as spike candidates"
    - "Reflector uses two-pass signal reading (index pass via shell commands on markdown table, detail pass for qualifying clusters only)"
    - "Reflector applies secondary clustering fallback (cross-type: 3+ overlapping tags, any signal_type) when primary yields fewer than 5 patterns"
    - "SIG-format signals counted separately in lifecycle dashboard as Legacy (read-only), not as Untriaged"
    - "Triage write includes a reconstructFrontmatter() roundtrip validation step before any bulk writes"
  artifacts:
    - path: "agents/gsd-reflector.md"
      provides: "Complete lifecycle-aware reflector agent with all REFLECT-01 through REFLECT-08 capabilities"
      min_lines: 400
  key_links:
    - from: "agents/gsd-reflector.md"
      to: "get-shit-done/references/reflection-patterns.md"
      via: "@references directive"
      pattern: "reflection-patterns.md"
    - from: "agents/gsd-reflector.md"
      to: "agents/kb-templates/lesson.md"
      via: "@references directive for lesson creation"
      pattern: "kb-templates/lesson.md"
    - from: "agents/gsd-reflector.md"
      to: "get-shit-done/workflows/reflect.md"
      via: "Workflow spawns reflector"
      pattern: "gsd-reflector"
---

<objective>
Rewrite gsd-reflector.md as a lifecycle-aware reflector with confidence-weighted pattern detection, counter-evidence seeking, triage proposals, remediation suggestions, lesson distillation with evidence snapshots, and spike candidate identification.

Purpose: This is the core implementation of Phase 33 -- the reflector agent spec is where all 8 REFLECT requirements come together. Plans 01 and 02 established the detection rules and output infrastructure. This plan rewrites the reflector to USE those rules and PRODUCE that output. The reflector transforms accumulated signals into actionable triage decisions, distilled lessons, and remediation suggestions.

Output: Complete rewrite of gsd-reflector.md implementing REFLECT-01 through REFLECT-08.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-enhanced-reflector/33-RESEARCH.md
@.planning/phases/33-enhanced-reflector/33-01-SUMMARY.md
@.planning/phases/33-enhanced-reflector/33-02-SUMMARY.md
@agents/gsd-reflector.md
@get-shit-done/references/reflection-patterns.md
@get-shit-done/workflows/reflect.md
@agents/kb-templates/lesson.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite reflector with lifecycle-aware analysis and confidence-weighted detection</name>
  <files>agents/gsd-reflector.md</files>
  <action>
Rewrite gsd-reflector.md as a major upgrade. Preserve the existing frontmatter (name, description, tools, color) and the `<required_reading>` section. Replace the execution_flow and guidelines sections with lifecycle-aware versions.

**Preserve unchanged:**
- Frontmatter (name, description, tools, color)
- `<role>` section (update to mention lifecycle awareness, triage, remediation)
- `<references>` section (keep existing references)
- `<inputs>` section (keep existing, NO new flags needed -- lifecycle features activate automatically)
- `<required_reading>` section

**Rewrite `<execution_flow>` with these steps:**

**Step 1: Load Configuration** (keep existing)

**Step 2: Load Signals with Lifecycle Awareness (REFLECT-01)**

Replace the current Step 2 with a two-pass approach:

a. **Index pass:** Read `~/.gsd/knowledge/index.md` and parse the markdown table using shell commands (grep/awk). **IMPORTANT: The index is a markdown table, NOT YAML frontmatter -- do NOT use extractFrontmatter() for this.** The table has columns: `| ID | Project | Severity | Lifecycle | Tags | Date | Status |`. For each signal row matching scope:
   - Extract columns by splitting on `|` delimiters using awk
   - For signals missing lifecycle_state column or with empty Lifecycle: default to `detected`
   - For SIG-format signals (ID starts with `SIG-`): mark as legacy, treat as read-only. **Note:** 5 SIG-format entries have malformed index rows (empty project/date, non-standard status values like `resolved`/`open`). Skip rows with empty Project column or infer project from the signal's directory path.
   - Build a metadata list WITHOUT reading full signal files

b. **Lifecycle filtering:**
   - `detected` (or absent): Full analysis candidate -- include in pattern detection, triage proposals, lesson distillation
   - `triaged`: Include in pattern detection and lesson distillation. SKIP triage proposals (already triaged). Show triage.decision in report.
   - `remediated`: Lower weight in pattern detection (multiply weight by 0.5). Track for dashboard.
   - `verified`: Exclude from pattern detection. Include in positive pattern analysis only.
   - `invalidated`: Exclude entirely from all analysis.

c. **Lifecycle dashboard data:** Count signals by state for dashboard output (passed back to workflow). **SIG-format signals go in a separate "Legacy (read-only)" row**, not in "Untriaged". This prevents 15 permanently-untriageable signals from inflating the untriaged count as the project matures.

**Step 3: Detect Patterns with Confidence-Weighted Scoring (REFLECT-02)**

Replace the current Step 3 with confidence-weighted detection:

a. **Cluster signals** using primary criteria from reflection-patterns.md Section 2.2 (same signal_type + 2+ overlapping tags). Positive and negative signals cluster separately.

a2. **Secondary clustering fallback:** If primary clustering yields fewer than 5 qualifying patterns, apply the relaxed mode from reflection-patterns.md Section 2.2: same project + 3+ overlapping tags + any signal_type. This addresses `signal_type` fragmentation -- signals about the same issue typed as `deviation`, `struggle`, and `config-mismatch` would otherwise never cluster. Secondary clusters get a 0.8x score multiplier and are marked as "cross-type" in output. **Why this matters:** The existing 50 signals use at least 5 different signal_types. Manual cluster analysis identified 7+ thematic groups, but the primary algorithm may only find 3-4 due to type fragmentation. The fallback ensures the 5-lesson success criterion is achievable.

b. **For each cluster, compute weighted_score:**
```
weighted_score = sum(weight(signal) for signal in cluster)
weight(signal) = confidence_weight * severity_multiplier * lifecycle_modifier

confidence_weight: high -> 2.0, medium -> 1.0, low -> 0.5
  (default medium for signals missing confidence field)
severity_multiplier: critical -> 1.5, notable -> 1.0, minor -> 0.7
lifecycle_modifier: detected/triaged -> 1.0, remediated -> 0.5
```

c. **Apply threshold** based on max severity in cluster (from reflection-patterns.md Section 2.1):
   - critical: 3.0
   - notable: 4.0
   - minor: 5.0

d. **Detail pass:** For clusters that meet the threshold, NOW read the full signal files to get body content, evidence, and detailed context. This is the second pass -- only qualifying clusters trigger full file reads.

**Step 3.5: Counter-Evidence Seeking (REFLECT-03)**

New step after pattern detection:

a. For each qualifying pattern, search for counter-evidence per reflection-patterns.md Section 2.5. **Use index metadata first** to identify candidates (tags, signal_category, lifecycle_state columns from the index pass), then read full signal files ONLY for confirmed counter-evidence candidates (max 3 per pattern). This preserves the two-pass context budget model -- counter-evidence candidates may be outside qualifying clusters (e.g., a lone positive signal), so searching the full corpus via index metadata is necessary, but full file reads remain bounded.
   - Check index for signals with same tags but `signal_category: positive`
   - Check index for signals with same tags and `lifecycle_state: remediated` or `verified`
   - Check time-decay (all signals > 30 days old with no recent recurrence) -- computable from index Date column

b. Bounded to 3 counter-examples per pattern. Total additional file reads for counter-evidence: at most 3 * N_qualifying_patterns.

c. Adjust pattern confidence based on counter-evidence found:
   - 0: Pattern confirmed
   - 1: Reduce confidence one level
   - 2-3: Reduce confidence two levels or flag as "investigate"

d. Record counter-evidence in pattern details.

**Step 4: Phase-End Reflection** (keep existing Step 4 largely unchanged)

**Step 5: Generate Triage Proposals (REFLECT-05)**

New step. For each qualifying pattern where cluster signals are in `detected` state:

a. Generate triage proposal:
```yaml
proposal:
  cluster: "{pattern-name}"
  signals: [sig-xxx, sig-yyy, sig-zzz]
  recommended_decision: address | dismiss | defer | investigate
  rationale: "..."
  recommended_priority: critical | high | medium | low
  recommended_action: "..."
```

b. Decision logic:
   - `address`: Pattern has clear root cause AND actionable fix AND high/medium confidence
   - `dismiss`: Pattern is noise OR all signals are stale with no recurrence
   - `defer`: Pattern exists but is low priority (minor severity, low confidence)
   - `investigate`: Pattern needs spike -- unclear root cause, counter-evidence found, or low confidence after adjustment

c. SIG-format signals are NEVER included in triage write operations (read-only legacy data). They contribute to pattern detection but are not themselves triaged.

d. **Phase 33 triage constraint:** When writing triage fields to critical signals that lack lifecycle_state, the reflector MUST FIRST add `evidence: { supporting: ["...at least one entry..."] }`. Validate with `frontmatter validate --schema signal` after modification. Reference 31-04 backward_compat rule.

e. **Roundtrip validation (run ONCE before any bulk triage writes):**
   - Pick one non-critical signal with simple frontmatter
   - Read it, parse with extractFrontmatter(), add a test triage object: `triage: { decision: "address", rationale: "roundtrip test", priority: "medium", by: "reflector", at: "2026-02-28T10:00:00Z" }` and `lifecycle_state: "triaged"` and a lifecycle_log entry with colons in the timestamp
   - Reconstruct with reconstructFrontmatter() + spliceFrontmatter()
   - Parse the result AGAIN with extractFrontmatter()
   - Verify: (1) triage.decision == "address", (2) triage.at preserved with colons, (3) lifecycle_log entry preserved with colons, (4) all frozen fields identical to original
   - **If roundtrip fails:** STOP all triage writes, report the failure in the reflection report, and recommend manual investigation. Do NOT proceed with bulk triage if the roundtrip is broken.
   - **If roundtrip passes:** Proceed with bulk triage writes using the pattern below.
   - **Why this is critical:** reconstructFrontmatter() has known quirks (drops nulls, normalizes empty objects to bare keys, quotes strings with colons). A populated triage object with nested fields and timestamps has never been empirically validated in a roundtrip. This one-time test catches the issue before it corrupts 20+ signal files.
   - **TDD safety net:** Unit tests in `gsd-tools-fork.test.js` ("frontmatter roundtrip with populated triage/lifecycle objects") now validate this roundtrip permanently. Three tests cover: (1) populated triage object validates with colon-containing timestamps, (2) full write-read-validate roundtrip via spliceFrontmatter preserves frozen fields and mutable triage fields, (3) backward_compat constraint (critical signals need evidence when lifecycle_state present). These tests run in CI and catch regressions if extractFrontmatter/reconstructFrontmatter behavior ever changes.

f. Triage write pattern (for approved proposals, after roundtrip validation passes):
   - Read complete signal file
   - Parse frontmatter with extractFrontmatter()
   - Add/update ONLY mutable fields: lifecycle_state, triage, lifecycle_log, updated
   - Reconstruct frontmatter + original body via spliceFrontmatter()
   - Write back and validate with `frontmatter validate --schema signal`
   - Confirm frozen fields are unchanged via before/after comparison of frozen field values

**Step 6: Distill Lessons with Evidence Snapshots (REFLECT-04)**

Enhance existing Step 5 (lesson distillation):

a. Keep existing distillation criteria (threshold met, consistent root cause, actionable).

b. **Add evidence_snapshots:** For each evidence signal, extract a one-sentence snapshot of the key observation. Include as `evidence_snapshots` field in lesson frontmatter:
```yaml
evidence_snapshots:
  - id: sig-xxx
    snapshot: "One-sentence summary of what this signal observed"
```

c. This makes lessons self-contained -- if evidence signals are later archived, the lesson still contains the key observations.

d. Use the updated kb-templates/lesson.md template (from Plan 02) which includes the evidence_snapshots and confidence fields.

**Step 7: Generate Remediation Suggestions (REFLECT-06)**

New step. For each triaged cluster with decision `address`:

a. Generate plan-level remediation suggestion (NOT action-level):
```markdown
### Remediation Suggestion: {cluster-name}

**Signals:** {signal IDs}
**Suggested approach:** {what to do}
**Suggested plan scope:** {which phase/plan could address this}
**Priority:** {from triage.priority}
```

b. The reflector does NOT write remediation fields to signals. It only suggests. Phase 34 handles `resolves_signals`.

**Step 8: Flag Spike Candidates (REFLECT-08)**

New step. Identify spike candidates per reflection-patterns.md Section 12:

a. Patterns with triage.decision = "investigate"
b. Patterns with adjusted confidence = "low" after counter-evidence
c. Marginal patterns (weighted score within 20% of threshold but below)

Format each as a spike candidate with question, rationale, and suggested experiment.

**Step 9: Semantic Drift Check** (keep existing Step 6, renumber)

**Step 10: Report Results** (keep existing Step 7, renumber)

Update output_format to include:
- Lifecycle Dashboard section (from workflow, but agent populates data)
- Triage Proposals section
- Remediation Suggestions section
- Spike Candidates section
- Evidence snapshots in lesson output

**Rewrite `<guidelines>` section:**

Keep all existing guidelines and ADD:
- Two-pass signal reading: index pass first (parse markdown table with shell commands, NOT extractFrontmatter), detail pass only for qualifying clusters (context budget management)
- Secondary clustering fallback: if primary yields <5 patterns, relax to 3+ overlapping tags across any signal_type (0.8x score multiplier, marked "cross-type")
- Legacy SIG-format signals: read-only for analysis, never modify, infer missing fields (lifecycle_state -> detected, signal_category -> from polarity or type). Count separately as "Legacy (read-only)" in dashboard, NOT as "Untriaged"
- Phase 33 triage constraint: critical signals need evidence before lifecycle_state (reference knowledge-store.md Section 4.2)
- Mutability boundary: list frozen vs mutable fields explicitly
- Counter-evidence uses index-first search: identify candidates from index metadata (tags, signal_category, lifecycle_state), read full files only for confirmed candidates (max 3 per pattern)
- Per-run triage cap: max 10 signals triaged per reflect run. Present highest-priority proposals first, queue remainder.
- reconstructFrontmatter() roundtrip validation: run once before any bulk triage writes. If roundtrip fails, halt all triage and report.
- Category taxonomy: use reflection-patterns.md Section 8 as authoritative. Map legacy categories: debugging->testing, performance->architecture, other->workflow.
- Remediation suggestions are plan-level, not action-level
- Spike candidates are identified, not created (reflector reports them, user/spike-runner acts)
- Phase 34 dependency: include note that triaged signals remain at "triaged" until Signal-Plan Linkage ships
  </action>
  <verify>
1. `wc -l agents/gsd-reflector.md` should be >= 400 lines (significant rewrite from 280)
2. `grep "lifecycle_state" agents/gsd-reflector.md` returns multiple matches
3. `grep "weighted_score" agents/gsd-reflector.md` returns matches (confidence-weighted scoring)
4. `grep "counter-evidence\|counter_evidence" agents/gsd-reflector.md` returns matches
5. `grep "triage proposal\|triage_proposal" agents/gsd-reflector.md` returns matches
6. `grep "evidence_snapshots" agents/gsd-reflector.md` returns matches
7. `grep "remediation suggestion\|Remediation Suggestion" agents/gsd-reflector.md` returns matches
8. `grep "spike candidate\|Spike Candidate" agents/gsd-reflector.md` returns matches
9. `grep "two-pass\|index pass\|detail pass" agents/gsd-reflector.md` returns matches (context budget management)
10. `grep "SIG-format\|SIG-" agents/gsd-reflector.md` returns matches (legacy handling)
11. `grep "Phase 33 triage constraint\|triage constraint" agents/gsd-reflector.md` returns match (safety note)
12. `grep "roundtrip\|reconstructFrontmatter" agents/gsd-reflector.md` returns matches (roundtrip validation)
13. `grep "secondary clustering\|cross-type\|fallback" agents/gsd-reflector.md` returns matches (clustering fallback)
14. `grep "index-first\|index metadata" agents/gsd-reflector.md` returns matches (counter-evidence optimization)
15. `grep "triage cap\|10 signals" agents/gsd-reflector.md` returns match (per-run cap)
16. `grep "Legacy.*read-only" agents/gsd-reflector.md` returns match (SIG-format dashboard handling)
17. `grep "authoritative\|Section 8" agents/gsd-reflector.md` returns match (category taxonomy)
  </verify>
  <done>
gsd-reflector.md is a complete lifecycle-aware reflector implementing all 8 REFLECT requirements: lifecycle-aware analysis (REFLECT-01), confidence-weighted detection (REFLECT-02), counter-evidence seeking (REFLECT-03), lesson distillation with evidence snapshots (REFLECT-04), triage proposals (REFLECT-05), remediation suggestions (REFLECT-06), lifecycle dashboard data (REFLECT-07), and spike candidate flagging (REFLECT-08). Two-pass signal reading manages context budget. Legacy SIG-format signals handled as read-only. Phase 33 triage constraint documented.
  </done>
</task>

</tasks>

<verification>
1. All 8 REFLECT requirements traceable to specific execution flow steps:
   - REFLECT-01: Step 2 (lifecycle-aware loading)
   - REFLECT-02: Step 3 (confidence-weighted scoring)
   - REFLECT-03: Step 3.5 (counter-evidence seeking)
   - REFLECT-04: Step 6 (evidence snapshots in lessons)
   - REFLECT-05: Step 5 (triage proposals)
   - REFLECT-06: Step 7 (remediation suggestions)
   - REFLECT-07: Step 2c (lifecycle dashboard data)
   - REFLECT-08: Step 8 (spike candidates)
2. File size >= 400 lines (major rewrite from 280)
3. All grep checks from task verification pass
4. References to reflection-patterns.md, knowledge-store.md, and kb-templates/lesson.md preserved
</verification>

<success_criteria>
gsd-reflector.md implements all 8 REFLECT requirements as a lifecycle-aware reflector agent. The agent reads lifecycle state, computes confidence-weighted scores, seeks counter-evidence, generates triage proposals, distills evidence-snapshot lessons, suggests remediation, populates lifecycle dashboard data, and flags spike candidates. Two-pass signal reading prevents context budget overflow. Phase 33 triage constraint is respected for critical signals.
</success_criteria>

<output>
After completion, create `.planning/phases/33-enhanced-reflector/33-03-SUMMARY.md`
</output>
