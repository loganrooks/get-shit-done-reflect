---
phase: 27-workflow-dx-reliability
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/install.js
  - tests/unit/install.test.js
autonomous: true

must_haves:
  truths:
    - "Failed fs.mkdirSync produces error message identifying 'mkdirSync', the target path, and a contextual hint"
    - "Failed fs.cpSync produces error message identifying 'cpSync', the source path, the destination path, and a contextual hint"
    - "Failed fs.renameSync produces error message identifying 'renameSync', the source path, the destination path, and a contextual hint"
    - "safeFs wrapper re-throws the original error after logging (does not swallow errors)"
    - "All existing installer behavior is unchanged when file operations succeed (safeFs is transparent on success)"
  artifacts:
    - path: "bin/install.js"
      provides: "safeFs() helper function and wrapped mkdirSync/cpSync/renameSync calls"
      contains: "function safeFs"
    - path: "tests/unit/install.test.js"
      provides: "Tests verifying safeFs error messages for EACCES, ENOENT, ENOSPC error codes"
      contains: "safeFs"
  key_links:
    - from: "safeFs()"
      to: "fs.mkdirSync, fs.cpSync, fs.renameSync"
      via: "try-catch wrapper that logs descriptive error then re-throws"
      pattern: "safeFs\\('mkdirSync'|safeFs\\('cpSync'|safeFs\\('renameSync'"
    - from: "safeFs() error output"
      to: "console.error"
      via: "Template string with operation, source, destination, and hint"
      pattern: "operation.*failed.*src"
---

<objective>
Add a `safeFs()` wrapper function to the installer that wraps `fs.mkdirSync`, `fs.cpSync`, and `fs.renameSync` calls with try-catch blocks producing descriptive error messages on failure. Add tests verifying the error message format.

Purpose: DX-03 -- when installer file operations fail (permission errors, disk full, missing paths), users currently see unhelpful Node.js stack traces. The `safeFs()` wrapper produces messages identifying the operation, source path, destination path, and a contextual hint (e.g., "Check file/directory permissions" for EACCES).

Output: Updated install.js with safeFs() helper and wrapped calls, plus test coverage.
</objective>

<execution_context>
@/Users/rookslog/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rookslog/.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-workflow-dx-reliability/27-RESEARCH.md
@bin/install.js
@tests/unit/install.test.js
</context>

<pitfalls>
The following pitfalls have been audited and their mitigations are embedded in the task instructions below:

1. **Error swallowing:** safeFs MUST re-throw after logging. Marked CRITICAL in Task 2 implementation.
2. **Console capture in tests:** Tests must use `vi.spyOn(console, 'error')` with `mockImplementation(() => {})` and restore after each test. Explicit technique specified in Task 1.
3. **ANSI escape codes in assertions:** Error messages contain `yellow` and `reset` ANSI codes from install.js module scope. Tests MUST use `expect(str).toContain(substring)` — never exact string equality — to avoid brittle assertions on escape sequences.
4. **Path expression duplication:** Each wrapping duplicates the path expression as both the lambda body arg and the `src` arg (e.g., `path.join(newKBDir, 'signals')` appears twice). Verify each wrapping individually — do not bulk find-replace.
5. **Try-catch audit result:** None of the 19 target fs.mkdirSync/cpSync/renameSync calls are inside existing try-catch blocks. The existing try blocks in install.js wrap `fs.lstatSync` (lines 264, 285), `fs.readFileSync`/`JSON.parse` (lines 380, 1508, 1631, 1797, 1838), and `fs.readdirSync` (line 1692). All 19 target calls can be wrapped unconditionally.
6. **Regression from wrapping:** If existing tests fail after Task 3 wrapping, the most likely cause is the thunk lambda not passing through the return value. Verify `safeFs` returns `fn()` on the success path.
</pitfalls>

<tasks>

<task type="auto">
  <name>Task 1: Write safeFs tests (red — tests fail before implementation)</name>
  <files>tests/unit/install.test.js</files>
  <action>
    **TDD step: write tests first.** These tests will fail until Task 2 implements safeFs.

    First, add `safeFs` to the destructured import at the top of the test file:
    ```javascript
    const { replacePathsInContent, getGsdHome, migrateKB, countKBEntries, convertClaudeToCodexSkill, copyCodexSkills, generateCodexAgentsMd, generateCodexMcpConfig, convertClaudeToGeminiAgent, safeFs } = require('../../bin/install.js')
    ```

    Then add a new describe block `describe('safeFs', ...)` with these 5 tests:

    **Console capture technique:** In each test that checks error output, use this pattern:
    ```javascript
    const errors = [];
    const spy = vi.spyOn(console, 'error').mockImplementation((...args) => errors.push(args.join(' ')));
    try {
      // ... call safeFs that throws ...
    } catch (e) { /* expected */ }
    spy.mockRestore();
    // Now assert against errors array
    ```
    Import `vi` from vitest alongside the existing `describe, it, expect` import.

    **Test 1 — Returns value on success:**
    ```javascript
    it('returns the value from the wrapped function on success', () => {
      const result = safeFs('mkdirSync', () => 'ok', '/tmp/test');
      expect(result).toBe('ok');
    });
    ```

    **Test 2 — Re-throws the original error:**
    ```javascript
    it('re-throws the original error after logging', () => {
      const original = Object.assign(new Error('permission denied'), { code: 'EACCES' });
      expect(() => safeFs('mkdirSync', () => { throw original; }, '/tmp/test')).toThrow(original);
    });
    ```

    **Test 3 — EACCES error message format:**
    Use console capture. Call `safeFs('mkdirSync', throwEACCES, '/some/path')`. Assert:
    - `errors.some(line => line.includes('mkdirSync'))` — operation name present
    - `errors.some(line => line.includes('/some/path'))` — source path present
    - `errors.some(line => line.includes('Check file/directory permissions'))` — hint present

    Use `toContain()` or `.includes()` — NEVER exact string equality (ANSI escape codes in output).

    **Test 4 — ENOENT with destination path:**
    Use console capture. Call `safeFs('cpSync', throwENOENT, '/src/path', '/dest/path')`. Assert:
    - `errors.some(line => line.includes('cpSync'))` — operation name
    - `errors.some(line => line.includes('/src/path') && line.includes('/dest/path'))` — both paths
    - `errors.some(line => line.includes('Source path does not exist'))` — hint

    **Test 5 — Unknown error code produces no hint line:**
    Use console capture. Throw error with `{ code: 'UNKNOWN' }`. Assert:
    - `errors.some(line => line.includes('mkdirSync'))` — operation still logged
    - `errors.every(line => !line.includes('Hint:'))` — no hint line emitted
  </action>
  <verify>
    ```bash
    cd /Users/rookslog/Development/get-shit-done-reflect && npx vitest run tests/unit/install.test.js 2>&1 | grep -E 'safeFs|FAIL|Tests|✓|×'
    ```
    The safeFs tests should FAIL (safeFs is not yet implemented). All OTHER existing tests should still PASS. This confirms the tests are wired correctly and testing the right import.

    NOTE: If the import fails because `safeFs` is not yet exported, that is expected and confirms the test is correctly importing from install.js. Proceed to Task 2.
  </verify>
  <done>5 safeFs tests written in install.test.js using vi.spyOn(console, 'error') capture pattern, all failing (red phase of TDD)</done>
</task>

<task type="auto">
  <name>Task 2: Implement safeFs() helper and export (green — tests pass)</name>
  <files>bin/install.js</files>
  <action>
    **TDD step: implement to make tests pass.**

    **In bin/install.js:**

    Add the `safeFs()` helper function near the top of the file (after the color constants on line 14, before the `pkg` require on line 17). Implementation:

    ```javascript
    /**
     * Safe wrapper for fs operations with descriptive error messages.
     * Wraps fs.*Sync calls in try-catch, logs operation/path/hint on failure, re-throws.
     * @param {string} operation - Name of the operation (e.g., 'mkdirSync', 'cpSync', 'renameSync')
     * @param {Function} fn - The fs function to call (thunk)
     * @param {string} src - Source path (or target for mkdir)
     * @param {string} [dest] - Destination path (for copy/rename)
     */
    function safeFs(operation, fn, src, dest) {
      try {
        return fn();
      } catch (err) {
        const destMsg = dest ? ` -> ${dest}` : '';
        const hint = {
          EACCES: 'Check file/directory permissions',
          ENOSPC: 'Check available disk space',
          ENOENT: 'Source path does not exist',
          EPERM: 'Operation not permitted (check ownership)',
          EEXIST: 'Destination already exists',
        }[err.code] || '';
        console.error(`  ${yellow}!${reset} ${operation} failed: ${src}${destMsg}`);
        console.error(`    Error: ${err.message}`);
        if (hint) console.error(`    Hint: ${hint}`);
        throw err;
      }
    }
    ```

    CRITICAL: The wrapper must ALWAYS re-throw the error. It adds logging, not error suppression.

    **Export safeFs for testing:** Add `safeFs` to the existing `module.exports` object at the bottom of install.js (line ~2409). Follow the existing pattern:
    ```javascript
    module.exports = { replacePathsInContent, getGsdHome, migrateKB, countKBEntries, installKBScripts, convertClaudeToCodexSkill, copyCodexSkills, generateCodexAgentsMd, generateCodexMcpConfig, convertClaudeToGeminiAgent, safeFs };
    ```
  </action>
  <verify>
    ```bash
    cd /Users/rookslog/Development/get-shit-done-reflect && npx vitest run tests/unit/install.test.js 2>&1 | grep -E 'safeFs|FAIL|Tests|✓|×|passed|failed'
    ```
    ALL tests pass — both the 5 new safeFs tests (now green) AND all existing tests (zero regressions).
  </verify>
  <done>safeFs() implemented in install.js and exported. All 5 TDD tests now pass (green phase).</done>
</task>

<task type="auto">
  <name>Task 3: Wrap all mkdirSync, cpSync, and renameSync calls with safeFs()</name>
  <files>bin/install.js</files>
  <action>
    Systematically wrap every `fs.mkdirSync`, `fs.cpSync`, and `fs.renameSync` call in install.js with the `safeFs()` helper.

    **Try-catch audit result:** None of the 19 target calls are inside existing try-catch blocks. All 19 can be wrapped unconditionally. (The existing try blocks at lines 264, 285, 380, 1508, 1631, 1692, 1797, 1838 wrap different operations: lstatSync, readFileSync, JSON.parse, readdirSync.)

    **fs.mkdirSync (16 calls):**
    Replace each `fs.mkdirSync(dir, { recursive: true })` with:
    `safeFs('mkdirSync', () => fs.mkdirSync(dir, { recursive: true }), dir)`

    For each call site, use the actual variable/expression as the `src` argument. Examples:
    - `fs.mkdirSync(path.join(newKBDir, 'signals'), { recursive: true })` becomes
      `safeFs('mkdirSync', () => fs.mkdirSync(path.join(newKBDir, 'signals'), { recursive: true }), path.join(newKBDir, 'signals'))`

    **WARNING — path expression duplication:** Each wrapping duplicates the path expression as both the thunk body and the `src` parameter. For computed paths like `path.join(...)`, both copies MUST be identical. Verify each wrapping individually — do NOT bulk find-replace. After wrapping each call, visually confirm the path expression inside the lambda matches the `src` argument.

    **fs.cpSync (2 calls):**
    Replace each `fs.cpSync(src, dest, opts)` with:
    `safeFs('cpSync', () => fs.cpSync(src, dest, opts), src, dest)`

    For the two call sites in migrateKB:
    - `fs.cpSync(newKBDir, backupDir, { recursive: true })` becomes
      `safeFs('cpSync', () => fs.cpSync(newKBDir, backupDir, { recursive: true }), newKBDir, backupDir)`
    - `fs.cpSync(oldKBDir, newKBDir, { recursive: true })` becomes
      `safeFs('cpSync', () => fs.cpSync(oldKBDir, newKBDir, { recursive: true }), oldKBDir, newKBDir)`

    **fs.renameSync (1 call):**
    Replace `fs.renameSync(oldKBDir, finalBackupDir)` with:
    `safeFs('renameSync', () => fs.renameSync(oldKBDir, finalBackupDir), oldKBDir, finalBackupDir)`

    IMPORTANT:
    - Do NOT wrap `fs.writeFileSync`, `fs.readFileSync`, `fs.copyFileSync`, `fs.unlinkSync`, `fs.rmSync` -- only the three named operation types per the success criteria
    - Preserve the exact same options/arguments to each fs call -- safeFs is a transparent wrapper
    - Some mkdirSync calls use just `{ recursive: true }`, which rarely fails. Wrap them anyway for consistency per the requirement

    **Rollback guidance:** If existing tests fail after wrapping, the most likely cause is the thunk lambda not returning (swallowing the return value). Verify the `safeFs` function definition has `return fn();` on the success path. A secondary cause could be a path expression mismatch between the lambda and the `src` arg — but this would only surface at runtime on error, not in success-path tests.
  </action>
  <verify>
    ```bash
    cd /Users/rookslog/Development/get-shit-done-reflect && npx vitest run tests/unit/install.test.js 2>&1 | grep -E 'FAIL|Tests|passed|failed'
    ```
    All existing tests still pass (wrapping with safeFs is transparent on success). Zero regressions.

    ```bash
    cd /Users/rookslog/Development/get-shit-done-reflect && grep -c "safeFs(" bin/install.js
    ```
    Expected count: **21** (19 wrapped call sites + 1 function definition + 1 module.exports line).

    ```bash
    cd /Users/rookslog/Development/get-shit-done-reflect && grep -n "fs\.mkdirSync\|fs\.cpSync\|fs\.renameSync" bin/install.js | grep -v "safeFs"
    ```
    Expected: **zero lines**. Every `fs.mkdirSync`, `fs.cpSync`, and `fs.renameSync` must appear on a line that also contains `safeFs`. If any lines appear, they are unwrapped calls that need fixing.
  </verify>
  <done>All 19 fs.mkdirSync, fs.cpSync, and fs.renameSync calls in install.js are wrapped with safeFs(), producing descriptive error messages on failure while maintaining identical behavior on success</done>
</task>

</tasks>

<verification>
```bash
# Run full test suite — check for pass/fail signal (not tail, which can truncate)
cd /Users/rookslog/Development/get-shit-done-reflect && npx vitest run tests/unit/install.test.js 2>&1 | grep -E 'FAIL|Tests|passed|failed|safeFs'

# Verify safeFs function exists
grep "function safeFs" bin/install.js

# Verify safeFs is exported
grep "safeFs" bin/install.js | grep "module.exports\|exports"

# Count all safeFs occurrences (expected: 21 = 19 call sites + 1 definition + 1 export)
grep -c "safeFs(" bin/install.js

# Verify NO unwrapped direct calls remain (expected: zero lines output)
grep -n "fs\.mkdirSync\|fs\.cpSync\|fs\.renameSync" bin/install.js | grep -v "safeFs"
```
</verification>

<success_criteria>
- safeFs() function exists in install.js
- safeFs() logs operation name, source path, destination path (when applicable), and error hint
- safeFs() always re-throws the error after logging
- All 16 fs.mkdirSync calls wrapped with safeFs()
- All 2 fs.cpSync calls wrapped with safeFs()
- The 1 fs.renameSync call wrapped with safeFs()
- 5 tests verify safeFs error message format and behavior
- All existing install.test.js tests pass with zero regressions
- grep -v "safeFs" filter on direct fs calls returns zero lines (no unwrapped calls)
</success_criteria>

<output>
After completion, create `.planning/phases/27-workflow-dx-reliability/27-02-SUMMARY.md`
</output>
