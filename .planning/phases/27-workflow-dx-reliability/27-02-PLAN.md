---
phase: 27-workflow-dx-reliability
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/install.js
  - tests/unit/install.test.js
autonomous: true

must_haves:
  truths:
    - "Failed fs.mkdirSync produces error message identifying 'mkdirSync', the target path, and a contextual hint"
    - "Failed fs.cpSync produces error message identifying 'cpSync', the source path, the destination path, and a contextual hint"
    - "Failed fs.renameSync produces error message identifying 'renameSync', the source path, the destination path, and a contextual hint"
    - "safeFs wrapper re-throws the original error after logging (does not swallow errors)"
    - "All existing installer behavior is unchanged when file operations succeed (safeFs is transparent on success)"
  artifacts:
    - path: "bin/install.js"
      provides: "safeFs() helper function and wrapped mkdirSync/cpSync/renameSync calls"
      contains: "function safeFs"
    - path: "tests/unit/install.test.js"
      provides: "Tests verifying safeFs error messages for EACCES, ENOENT, ENOSPC error codes"
      contains: "safeFs"
  key_links:
    - from: "safeFs()"
      to: "fs.mkdirSync, fs.cpSync, fs.renameSync"
      via: "try-catch wrapper that logs descriptive error then re-throws"
      pattern: "safeFs\\('mkdirSync'|safeFs\\('cpSync'|safeFs\\('renameSync'"
    - from: "safeFs() error output"
      to: "console.error"
      via: "Template string with operation, source, destination, and hint"
      pattern: "operation.*failed.*src"
---

<objective>
Add a `safeFs()` wrapper function to the installer that wraps `fs.mkdirSync`, `fs.cpSync`, and `fs.renameSync` calls with try-catch blocks producing descriptive error messages on failure. Add tests verifying the error message format.

Purpose: DX-03 -- when installer file operations fail (permission errors, disk full, missing paths), users currently see unhelpful Node.js stack traces. The `safeFs()` wrapper produces messages identifying the operation, source path, destination path, and a contextual hint (e.g., "Check file/directory permissions" for EACCES).

Output: Updated install.js with safeFs() helper and wrapped calls, plus test coverage.
</objective>

<execution_context>
@/Users/rookslog/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rookslog/.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-workflow-dx-reliability/27-RESEARCH.md
@bin/install.js
@tests/unit/install.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add safeFs() helper and tests</name>
  <files>bin/install.js, tests/unit/install.test.js</files>
  <action>
    **In bin/install.js:**

    Add a `safeFs()` helper function near the top of the file (after the color constants, before existing functions). Implementation:

    ```javascript
    /**
     * Safe wrapper for fs operations with descriptive error messages.
     * Wraps fs.*Sync calls in try-catch, logs operation/path/hint on failure, re-throws.
     * @param {string} operation - Name of the operation (e.g., 'mkdirSync', 'cpSync', 'renameSync')
     * @param {Function} fn - The fs function to call (thunk)
     * @param {string} src - Source path (or target for mkdir)
     * @param {string} [dest] - Destination path (for copy/rename)
     */
    function safeFs(operation, fn, src, dest) {
      try {
        return fn();
      } catch (err) {
        const destMsg = dest ? ` -> ${dest}` : '';
        const hint = {
          EACCES: 'Check file/directory permissions',
          ENOSPC: 'Check available disk space',
          ENOENT: 'Source path does not exist',
          EPERM: 'Operation not permitted (check ownership)',
          EEXIST: 'Destination already exists',
        }[err.code] || '';
        console.error(`  ${yellow}!${reset} ${operation} failed: ${src}${destMsg}`);
        console.error(`    Error: ${err.message}`);
        if (hint) console.error(`    Hint: ${hint}`);
        throw err;
      }
    }
    ```

    CRITICAL: The wrapper must ALWAYS re-throw the error. It adds logging, not error suppression.

    **Export safeFs for testing:** The install.js file uses `module.exports` at the bottom for test access. Add `safeFs` to the exports object (follow the existing pattern used by `migrateKB`, `countKBEntries`, etc.).

    **In tests/unit/install.test.js:**

    Add a new describe block `describe('safeFs', ...)` with tests:

    1. **Returns value on success:** `safeFs('mkdirSync', () => 'ok', '/tmp/test')` returns `'ok'`

    2. **Re-throws on error:** `safeFs('mkdirSync', () => { throw Object.assign(new Error('permission denied'), { code: 'EACCES' }); }, '/tmp/test')` throws the same error

    3. **EACCES error message format:** Capture console.error output. Verify it contains:
       - The operation name: `'mkdirSync'`
       - The source path: `'/some/path'`
       - The hint: `'Check file/directory permissions'`

    4. **ENOENT error message format with destination:** Capture console.error. Call with src and dest params. Verify output contains:
       - The operation name: `'cpSync'`
       - The source path AND destination path: `'/src/path -> /dest/path'`
       - The hint: `'Source path does not exist'`

    5. **Unknown error code produces no hint:** Error with code 'UNKNOWN' logs operation and path but no hint line

    Follow the existing test patterns in install.test.js (vitest, describe/it/expect).
  </action>
  <verify>
    ```bash
    cd /Users/rookslog/Development/get-shit-done-reflect && npx vitest run tests/unit/install.test.js 2>&1 | tail -20
    ```
    All tests pass including the new safeFs tests.
  </verify>
  <done>safeFs() helper exists in install.js with 5 tests verifying error message format, re-throw behavior, and hint selection by error code</done>
</task>

<task type="auto">
  <name>Task 2: Wrap all mkdirSync, cpSync, and renameSync calls with safeFs()</name>
  <files>bin/install.js</files>
  <action>
    Systematically wrap every `fs.mkdirSync`, `fs.cpSync`, and `fs.renameSync` call in install.js with the `safeFs()` helper. The research identified:

    **fs.mkdirSync (14 calls):**
    Replace each `fs.mkdirSync(dir, { recursive: true })` with:
    `safeFs('mkdirSync', () => fs.mkdirSync(dir, { recursive: true }), dir)`

    For each call site, use the actual variable name as the `src` argument. Examples:
    - `fs.mkdirSync(path.join(newKBDir, 'signals'), { recursive: true })` becomes
      `safeFs('mkdirSync', () => fs.mkdirSync(path.join(newKBDir, 'signals'), { recursive: true }), path.join(newKBDir, 'signals'))`

    **fs.cpSync (2 calls):**
    Replace each `fs.cpSync(src, dest, opts)` with:
    `safeFs('cpSync', () => fs.cpSync(src, dest, opts), src, dest)`

    For the two call sites (lines ~243 and ~300 in migrateKB):
    - `fs.cpSync(newKBDir, backupDir, { recursive: true })` becomes
      `safeFs('cpSync', () => fs.cpSync(newKBDir, backupDir, { recursive: true }), newKBDir, backupDir)`
    - `fs.cpSync(oldKBDir, newKBDir, { recursive: true })` becomes
      `safeFs('cpSync', () => fs.cpSync(oldKBDir, newKBDir, { recursive: true }), oldKBDir, newKBDir)`

    **fs.renameSync (1 call):**
    Replace `fs.renameSync(oldKBDir, finalBackupDir)` with:
    `safeFs('renameSync', () => fs.renameSync(oldKBDir, finalBackupDir), oldKBDir, finalBackupDir)`

    IMPORTANT:
    - Do NOT wrap `fs.writeFileSync`, `fs.readFileSync`, `fs.copyFileSync`, `fs.unlinkSync`, `fs.rmSync` -- only the three named operation types per the success criteria
    - Do NOT wrap calls that are already inside their own try-catch blocks (check each call site)
    - Preserve the exact same options/arguments to each fs call -- safeFs is a transparent wrapper
    - Some mkdirSync calls use just `{ recursive: true }`, which rarely fails. Wrap them anyway for consistency per the requirement
  </action>
  <verify>
    ```bash
    cd /Users/rookslog/Development/get-shit-done-reflect && npx vitest run tests/unit/install.test.js 2>&1 | tail -20
    ```
    All existing tests still pass (wrapping with safeFs is transparent on success).

    ```bash
    cd /Users/rookslog/Development/get-shit-done-reflect && grep -c "safeFs(" bin/install.js
    ```
    Should return 17+ (14 mkdirSync + 2 cpSync + 1 renameSync = 17 wrapped calls, plus the function definition).

    ```bash
    cd /Users/rookslog/Development/get-shit-done-reflect && grep -c "fs\.mkdirSync\|fs\.cpSync\|fs\.renameSync" bin/install.js
    ```
    All remaining direct fs.mkdirSync/cpSync/renameSync calls should be inside safeFs lambdas.
  </verify>
  <done>All 17 fs.mkdirSync, fs.cpSync, and fs.renameSync calls in install.js are wrapped with safeFs(), producing descriptive error messages on failure while maintaining identical behavior on success</done>
</task>

</tasks>

<verification>
```bash
# Run full test suite
cd /Users/rookslog/Development/get-shit-done-reflect && npx vitest run tests/unit/install.test.js 2>&1 | tail -20

# Verify safeFs function exists
grep "function safeFs" bin/install.js

# Verify safeFs is exported
grep "safeFs" bin/install.js | grep "module.exports\|exports"

# Count wrapped calls (should be 17+)
grep -c "safeFs(" bin/install.js

# Verify no unwrapped direct calls remain (should only appear inside safeFs lambdas)
grep -n "fs\.mkdirSync\|fs\.cpSync\|fs\.renameSync" bin/install.js | head -20
```
</verification>

<success_criteria>
- safeFs() function exists in install.js
- safeFs() logs operation name, source path, destination path (when applicable), and error hint
- safeFs() always re-throws the error after logging
- All 14 fs.mkdirSync calls wrapped with safeFs()
- All 2 fs.cpSync calls wrapped with safeFs()
- The 1 fs.renameSync call wrapped with safeFs()
- 5 tests verify safeFs error message format and behavior
- All existing install.test.js tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/27-workflow-dx-reliability/27-02-SUMMARY.md`
</output>
