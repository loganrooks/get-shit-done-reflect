---
phase: 23-feature-manifest-foundation
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - get-shit-done/bin/gsd-tools.test.js
  - bin/install.js
  - .planning/config.json
autonomous: true

must_haves:
  truths:
    - "All manifest command tests pass via node --test"
    - "Installer verifies feature-manifest.json was copied to target after installation"
    - "config.json contains a manifest_version field matching the manifest's version"
    - "Tests confirm unknown config fields produce warnings not errors in validate"
    - "Tests confirm diff-config detects missing features, missing fields, and type mismatches"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.test.js"
      provides: "Test coverage for manifest diff-config, validate, and get-prompts"
      min_lines: 100
    - path: "bin/install.js"
      provides: "Post-install verification that feature-manifest.json exists"
      contains: "feature-manifest.json"
    - path: ".planning/config.json"
      provides: "manifest_version field for upgrade detection"
      contains: "manifest_version"
  key_links:
    - from: "get-shit-done/bin/gsd-tools.test.js"
      to: "get-shit-done/bin/gsd-tools.js manifest commands"
      via: "runGsdTools('manifest diff-config', tmpDir)"
      pattern: "manifest (diff-config|validate|get-prompts)"
    - from: "bin/install.js"
      to: "get-shit-done/feature-manifest.json"
      via: "post-copy verification check"
      pattern: "feature-manifest\\.json"
---

<objective>
Add comprehensive tests for all 3 manifest subcommands, verify the installer ships the manifest correctly, and add the manifest_version field to config.json for upgrade path detection.

Purpose: Ensure manifest tooling works correctly across edge cases and the manifest is properly shipped and versioned.
Output: Passing test suite, installer verification, config.json with manifest_version.
</objective>

<execution_context>
@/Users/rookslog/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rookslog/.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-feature-manifest-foundation/23-01-SUMMARY.md
@.planning/phases/23-feature-manifest-foundation/23-RESEARCH.md
@get-shit-done/bin/gsd-tools.js
@get-shit-done/bin/gsd-tools.test.js
@get-shit-done/feature-manifest.json
@bin/install.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add manifest command tests to gsd-tools.test.js</name>
  <files>get-shit-done/bin/gsd-tools.test.js</files>
  <action>
Add test suites for all 3 manifest subcommands to `get-shit-done/bin/gsd-tools.test.js`, following the existing test patterns (createTempProject, runGsdTools, cleanup).

Each test needs a temp directory with:
- `.claude/get-shit-done/feature-manifest.json` (a test manifest with a subset of features for focused testing)
- `.planning/config.json` (the config being tested)

**Test suite: `manifest diff-config`** (add `describe('manifest diff-config command', ...)`)

1. **detects missing feature section** - Config has no `health_check` key. Expect `missing_features` array contains health_check.

2. **detects missing field in existing section** - Config has `health_check: {}` (empty). Expect `missing_fields` contains frequency, stale_threshold_days, blocking_checks with their expected types and defaults.

3. **detects type mismatch** - Config has `health_check: { frequency: 123 }` (number instead of string). Expect `type_mismatches` array has entry with expected "string", actual "number".

4. **detects enum mismatch** - Config has `health_check: { frequency: "invalid-value" }`. Expect `enum_mismatches` array has entry.

5. **reports unknown fields as informational** - Config has `{ custom_setting: true, health_check: { frequency: "milestone-only" } }`. Expect `unknown_fields` array contains `custom_setting`.

6. **reports manifest and config versions** - Manifest has `manifest_version: 1`, config has `manifest_version: 1`. Expect both values in output.

7. **handles config without manifest_version** - Config has no manifest_version. Expect `config_manifest_version: null`.

**Test suite: `manifest validate`** (add `describe('manifest validate command', ...)`)

8. **valid config passes validation** - Config has correct types for all manifest fields. Expect `valid: true`, `errors: []`.

9. **config with unknown fields passes validation** - Config has `custom_field: true` plus valid feature data. Expect `valid: true` with warnings containing `unknown_field`.

10. **type mismatch produces error** - Config has `health_check: { frequency: 42 }`. Expect `valid: false`, errors array has type_mismatch.

11. **missing feature is warning not error** - Config has no health_check section. Expect `valid: true`, warnings has `missing_feature`.

12. **counts features correctly** - Manifest has 2 features, config has 1. Expect `features_checked: 2`, `features_present: 1`, `features_missing: 1`.

**Test suite: `manifest get-prompts`** (add `describe('manifest get-prompts command', ...)`)

13. **returns prompts for known feature** - Request health_check. Expect output has `feature: "health_check"`, `prompts` array with at least one entry, `schema` object.

14. **errors on unknown feature** - Request `nonexistent`. Expect command fails with error message listing available features.

15. **errors when no feature specified** - Run `manifest get-prompts` with no feature arg. Expect error about feature name required.

**Setup helper for manifest tests:**

Create a helper function `createManifestTestEnv(tmpDir, manifestFeatures, configObj)` that:
- Creates `.claude/get-shit-done/` directory
- Writes `feature-manifest.json` with given features
- Writes `.planning/config.json` with given config
- Returns tmpDir

Use a minimal test manifest with 1-2 features (health_check and optionally devops) to keep tests focused. Only the test that counts features needs 2 features.
  </action>
  <verify>
Run `node --test get-shit-done/bin/gsd-tools.test.js 2>&1 | tail -5` and verify all tests pass including the new manifest tests. No existing tests should be broken.
  </verify>
  <done>All manifest command tests pass. Tests cover: missing features, missing fields, type mismatches, enum mismatches, unknown fields as warnings (not errors), validation pass/fail, feature counting, prompt retrieval, and error cases.</done>
</task>

<task type="auto">
  <name>Task 2: Add installer manifest verification and manifest_version to config.json</name>
  <files>bin/install.js, .planning/config.json</files>
  <action>
**Part A: Installer verification (bin/install.js)**

The manifest file (`feature-manifest.json`) is already automatically copied by the existing `copyWithPathReplacement()` call at line 1942 of install.js because it lives inside the `get-shit-done/` directory. No copy logic changes needed.

Add a post-install verification check. Find the section where other installed files are verified (look for `verifyFileInstalled` calls or console.log messages about installed files). Add a verification that `feature-manifest.json` exists after installation:

After the `copyWithPathReplacement(skillSrc, skillDest, pathPrefix, runtime)` call (around line 1942), add a check:
```javascript
// Verify feature manifest was installed
const manifestDest = path.join(skillDest, 'feature-manifest.json');
if (fs.existsSync(manifestDest)) {
  console.log(`  ${green}+${reset} Feature manifest installed`);
} else {
  console.log(`  ${yellow}!${reset} Feature manifest not found (expected at ${manifestDest})`);
}
```

Use the same color variables (`green`, `yellow`, `reset`) already defined in install.js. If there is an existing verification pattern (like a `verifyFileInstalled` function), follow that pattern instead. Look for how other files are verified post-copy.

**Important:** Do NOT add any manifest-reading logic to install.js. The installer copies the file as a static asset. It must NOT `JSON.parse` the manifest or act on its contents. That would violate the scope boundary (installer = file shipping, gsd-tools = manifest logic).

**Part B: Add manifest_version to .planning/config.json**

Add `"manifest_version": 1` to the project's `.planning/config.json`. Place it after the `gsd_reflect_version` field at the end of the file. This allows `gsd-tools manifest diff-config` to detect version gaps between the installed manifest and the project's last-configured version.

The value `1` matches the `manifest_version` in the newly created `feature-manifest.json`.
  </action>
  <verify>
1. Verify config.json: `node -e "const c = JSON.parse(require('fs').readFileSync('.planning/config.json','utf-8')); console.log('manifest_version:', c.manifest_version); process.exit(c.manifest_version === 1 ? 0 : 1)"` exits 0.
2. Verify install.js contains verification: `grep -c 'feature-manifest' bin/install.js` returns at least 1.
3. Run `node get-shit-done/bin/gsd-tools.js manifest diff-config --raw` and verify `config_manifest_version` is now 1 (not null).
  </verify>
  <done>config.json has `manifest_version: 1`, install.js verifies manifest was copied post-installation, and diff-config reports config_manifest_version as 1.</done>
</task>

</tasks>

<verification>
1. `node --test get-shit-done/bin/gsd-tools.test.js` passes with 0 failures (including all new manifest tests)
2. `grep 'feature-manifest' bin/install.js` shows verification code
3. `node -e "const c=JSON.parse(require('fs').readFileSync('.planning/config.json','utf-8')); console.log(c.manifest_version)"` outputs `1`
4. `node get-shit-done/bin/gsd-tools.js manifest diff-config --raw` shows `config_manifest_version: 1`
</verification>

<success_criteria>
- All existing tests continue to pass
- New manifest tests (15+ test cases) all pass
- install.js logs confirmation that feature-manifest.json was installed
- config.json contains manifest_version: 1
- manifest diff-config now reports config_manifest_version as 1 instead of null
</success_criteria>

<output>
After completion, create `.planning/phases/23-feature-manifest-foundation/23-02-SUMMARY.md`
</output>
