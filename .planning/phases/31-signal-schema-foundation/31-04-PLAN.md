---
phase: 31-signal-schema-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/bin/gsd-tools.js
  - get-shit-done/bin/gsd-tools.test.js
  - agents/knowledge-store.md
  - .planning/FORK-DIVERGENCES.md
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "All 6 affected critical signals without evidence pass schema validation with valid: true when lifecycle_state is absent (backward compatibility mode)"
    - "New critical signals WITH lifecycle_state but WITHOUT evidence still fail validation with valid: false (strict enforcement preserved)"
    - "Backward compat evidence requirement appears in warnings array prefixed with backward_compat: rather than in missing array"
    - "New critical signal with empty evidence object (evidence: {}) but WITH lifecycle_state fails validation -- evidence content must have at least one supporting entry"
    - "knowledge-store.md Section 4.2 documents backward_compat validation behavior and Phase 33 triage constraint"
    - "FORK-DIVERGENCES.md gsd-tools.js entry updated with backward_compat note"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "backward_compat schema field, validation logic, and evidence content validation"
      contains: "backward_compat"
    - path: "get-shit-done/bin/gsd-tools.test.js"
      provides: "Tests for backward compatibility, evidence content validation, and strict enforcement"
      contains: "backward_compat"
    - path: "agents/knowledge-store.md"
      provides: "Documentation of backward_compat validation behavior and Phase 33 constraint"
      contains: "backward_compat"
    - path: ".planning/FORK-DIVERGENCES.md"
      provides: "Updated fork divergence entry for gsd-tools.js backward_compat"
      contains: "backward_compat"
  key_links:
    - from: "get-shit-done/bin/gsd-tools.js"
      to: "FRONTMATTER_SCHEMAS.signal"
      via: "backward_compat field triggers lenient conditional validation"
      pattern: "backward_compat"
    - from: "agents/knowledge-store.md"
      to: "get-shit-done/bin/gsd-tools.js"
      via: "Spec documents backward_compat validation behavior implemented in code"
      pattern: "backward_compat"
---

<objective>
Fix backward compatibility gap and harden evidence validation: 6 pre-existing critical signals fail schema validation because the conditional requirement `evidence REQUIRED for critical severity` does not distinguish pre-Phase 31 signals from new signals.

Purpose: The phase goal states "all 46 existing signals remain valid without migration." Currently 6 critical signals without evidence fail validation. Adding a backward_compat indicator keyed on lifecycle_state absence allows pre-existing signals to receive warnings instead of hard failures, while preserving strict enforcement for new signals. Additionally hardens evidence content validation (empty evidence objects are not sufficient), documents the backward_compat behavior in knowledge-store.md, and updates fork divergence tracking.

Output: Modified validation logic in gsd-tools.js, updated/new tests, documented backward_compat in knowledge-store.md, updated FORK-DIVERGENCES.md.
</objective>

<execution_context>
@/Users/rookslog/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rookslog/.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/31-signal-schema-foundation/31-VERIFICATION.md
@.planning/phases/31-signal-schema-foundation/31-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backward_compat schema field, evidence content validation, and Phase 33 warning to gsd-tools.js</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Three changes to `get-shit-done/bin/gsd-tools.js`:

**1. Add backward_compat to FRONTMATTER_SCHEMAS.signal (line ~2231)**

Add a `backward_compat` field to the signal schema definition with a comment warning about the Phase 33 interaction:

```javascript
signal: {
    required: ['id', 'type', 'project', 'tags', 'created', 'severity', 'signal_type'],
    conditional: [
      {
        when: { field: 'severity', value: 'critical' },
        require: ['evidence'],
        recommend: ['confidence', 'confidence_basis'],
      },
      {
        when: { field: 'severity', value: 'notable' },
        recommend: ['evidence', 'confidence'],
      },
    ],
    // Backward compat: when lifecycle_state is absent, conditional require -> recommend (warnings).
    // Pre-Phase 31 signals lack lifecycle_state. New signals from the template always have it.
    // IMPORTANT: Phase 33 bulk triage must add evidence BEFORE adding lifecycle_state to critical
    // signals, or they will fail validation once the backward_compat exemption no longer applies.
    backward_compat: { field: 'lifecycle_state' },
    recommended: ['lifecycle_state', 'signal_category', 'confidence', 'confidence_basis'],
    optional: ['triage', 'remediation', 'verification', 'lifecycle_log',
               'recurrence_of', 'phase', 'plan', 'polarity', 'source',
               'occurrence_count', 'related_signals', 'runtime', 'model',
               'gsd_version', 'durability', 'status'],
  },
```

**2. Update cmdFrontmatterValidate conditional loop (line ~2265-2283)**

After extracting frontmatter and before the conditional requirements loop, determine backward compatibility mode:

```javascript
// Determine backward compatibility mode: signals without lifecycle_state predate Phase 31
const backwardCompat = schema.backward_compat && fm[schema.backward_compat.field] === undefined;
```

Then modify the conditional require check to downgrade to warnings when in backward compat mode:

```javascript
if (cond.require) {
  for (const f of cond.require) {
    if (fm[f] === undefined) {
      if (backwardCompat) {
        conditionalWarnings.push(`backward_compat: ${f}`);
      } else {
        conditionalMissing.push(f);
      }
    }
  }
}
```

This ensures:
- Pre-existing signals (no lifecycle_state) get `backward_compat: evidence` as a warning, valid: true
- New signals (have lifecycle_state) get `evidence` in missing array, valid: false
- All other schemas (plan, summary, verification) are unaffected -- they have no backward_compat field

**3. Add evidence content validation for conditional require fields (after the conditional loop)**

After the existing conditional loop (line ~2283), add a content validation check for the `evidence` field specifically. An empty evidence object (`evidence: {}` or `evidence: { supporting: [], counter: [] }`) should not satisfy the conditional requirement for critical signals:

```javascript
// Evidence content validation: empty evidence objects don't satisfy the epistemic rigor requirement.
// evidence: {} or evidence: { supporting: [], counter: [] } are structurally present but epistemically empty.
if (!backwardCompat && schema.conditional) {
  for (const cond of schema.conditional) {
    if (fm[cond.when.field] === cond.when.value && cond.require) {
      for (const f of cond.require) {
        if (f === 'evidence' && fm.evidence !== undefined) {
          const ev = fm.evidence;
          const hasContent = ev.supporting && ev.supporting.length > 0;
          if (!hasContent) {
            conditionalMissing.push('evidence (empty)');
          }
        }
      }
    }
  }
}
```

This catches the case where a new critical signal has `evidence: {}` or `evidence: { supporting: [], counter: [] }` -- technically present but epistemically empty. The locked decision says "counter-evidence is a hard requirement for critical signals -- system refuses to save critical signal without counter-evidence." An empty evidence object violates this spirit.

Note: Only checks `supporting` has content (at least one entry). Counter-evidence emptiness is a warning, not a hard fail, because a signal creator may legitimately document "no counter-evidence found" as a narrative rather than structured counter entries.
  </action>
  <verify>
Run: `npm test`
All 155+ tests pass. No regressions in existing schema validation (plan, summary, verification).
Verify manually: `node get-shit-done/bin/gsd-tools.js frontmatter validate ~/.gsd/knowledge/signals/get-shit-done-reflect/2026-02-11-kb-data-loss-migration-gap.md --schema signal` returns valid: true with backward_compat warning.
  </verify>
  <done>
cmdFrontmatterValidate recognizes backward_compat schema field and downgrades conditional require to recommend when the indicator field is absent. Evidence content validation catches empty evidence objects on new critical signals. Phase 33 warning comment documents the triage constraint. Existing schemas unaffected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update and add tests for backward compatibility and evidence content validation</name>
  <files>get-shit-done/bin/gsd-tools.test.js</files>
  <action>
Five changes to `get-shit-done/bin/gsd-tools.test.js` in the `signal frontmatter validation` describe block:

**1. Update existing "invalid critical signal without evidence" test (line ~4365)**

This test currently creates a critical signal WITHOUT lifecycle_state and WITHOUT evidence, asserting valid: false. After the backward compat change, this signal would be treated as pre-existing (no lifecycle_state) and pass. Update the test to simulate a NEW critical signal by adding `lifecycle_state: detected`:

```javascript
test('invalid critical signal without evidence', () => {
    const signalPath = path.join(tmpDir, 'critical-no-evidence.md');
    fs.writeFileSync(signalPath, `---
id: sig-2026-02-28-critical-no-ev
type: signal
project: test-project
tags: [critical]
created: 2026-02-28T10:00:00Z
severity: critical
signal_type: deviation
lifecycle_state: detected
---

# Critical without evidence
`);

    const result = runGsdTools(`frontmatter validate ${signalPath} --schema signal`, tmpDir);
    assert.ok(result.success, `Command failed: ${result.error}`);
    const output = JSON.parse(result.output);
    assert.strictEqual(output.valid, false, 'new critical signal without evidence should be invalid');
    assert.ok(output.missing.includes('evidence'), 'missing should include evidence');
  });
```

**2. Add new test: "backward compat: critical signal without lifecycle_state downgrades evidence to warning"**

Add after the existing backward compatibility test (line ~4415):

```javascript
test('backward compat: critical signal without lifecycle_state downgrades evidence to warning', () => {
    const signalPath = path.join(tmpDir, 'pre-existing-critical.md');
    fs.writeFileSync(signalPath, `---
id: sig-2026-02-11-kb-data-loss-migration-gap
type: signal
project: get-shit-done-reflect
tags: [knowledge-base, migration]
created: 2026-02-11T10:00:00Z
severity: critical
signal_type: deviation
phase: 25
polarity: negative
source: executor
---

# Pre-existing critical signal without evidence
`);

    const result = runGsdTools(`frontmatter validate ${signalPath} --schema signal`, tmpDir);
    assert.ok(result.success, `Command failed: ${result.error}`);
    const output = JSON.parse(result.output);
    assert.strictEqual(output.valid, true, 'pre-existing critical signal without lifecycle_state should be valid');
    assert.strictEqual(output.missing.length, 0, 'no missing fields in backward compat mode');
    const warningStr = output.warnings.join(',');
    assert.ok(warningStr.includes('backward_compat: evidence'), 'should include backward_compat warning for evidence');
  });
```

**3. Add new test: "new critical signal with lifecycle_state but no evidence fails"**

Add after the previous new test:

```javascript
test('new critical signal with lifecycle_state but no evidence fails', () => {
    const signalPath = path.join(tmpDir, 'new-critical-no-evidence.md');
    fs.writeFileSync(signalPath, `---
id: sig-2026-02-28-new-critical
type: signal
project: test-project
tags: [schema]
created: 2026-02-28T10:00:00Z
severity: critical
signal_type: deviation
lifecycle_state: detected
signal_category: negative
---

# New critical signal without evidence
`);

    const result = runGsdTools(`frontmatter validate ${signalPath} --schema signal`, tmpDir);
    assert.ok(result.success, `Command failed: ${result.error}`);
    const output = JSON.parse(result.output);
    assert.strictEqual(output.valid, false, 'new critical signal with lifecycle_state but no evidence should fail');
    assert.ok(output.missing.includes('evidence'), 'missing should include evidence');
  });
```

**4. Add new test: "new critical signal with empty evidence object fails"**

Tests that `evidence: {}` and `evidence: { supporting: [], counter: [] }` don't satisfy the requirement. An epistemically empty evidence object should not pass validation for critical signals.

```javascript
test('new critical signal with empty evidence object fails', () => {
    const signalPath = path.join(tmpDir, 'critical-empty-evidence.md');
    fs.writeFileSync(signalPath, `---
id: sig-2026-02-28-empty-evidence
type: signal
project: test-project
tags: [schema]
created: 2026-02-28T10:00:00Z
severity: critical
signal_type: deviation
lifecycle_state: detected
signal_category: negative
evidence:
  supporting: []
  counter: []
confidence: medium
confidence_basis: "untested"
---

# Critical signal with empty evidence
`);

    const result = runGsdTools(`frontmatter validate ${signalPath} --schema signal`, tmpDir);
    assert.ok(result.success, `Command failed: ${result.error}`);
    const output = JSON.parse(result.output);
    assert.strictEqual(output.valid, false, 'critical signal with empty evidence should be invalid');
    assert.ok(output.missing.some(m => m.includes('evidence')), 'missing should include evidence (empty)');
  });
```

**5. Add new test: "backward compat mode does NOT apply when lifecycle_state is present"**

Verifies that once a signal has lifecycle_state (e.g., after Phase 33 bulk triage adds it), the backward compat exemption no longer applies. This documents the Phase 33 constraint in test form.

```javascript
test('backward compat mode does NOT apply when lifecycle_state is present', () => {
    const signalPath = path.join(tmpDir, 'triaged-critical-no-evidence.md');
    fs.writeFileSync(signalPath, `---
id: sig-2026-02-11-kb-data-loss-migration-gap
type: signal
project: get-shit-done-reflect
tags: [knowledge-base, migration]
created: 2026-02-11T10:00:00Z
severity: critical
signal_type: deviation
lifecycle_state: triaged
phase: 25
polarity: negative
source: executor
---

# Triaged critical signal still needs evidence
`);

    const result = runGsdTools(`frontmatter validate ${signalPath} --schema signal`, tmpDir);
    assert.ok(result.success, `Command failed: ${result.error}`);
    const output = JSON.parse(result.output);
    assert.strictEqual(output.valid, false, 'critical signal with lifecycle_state but no evidence should fail even with old created date');
    assert.ok(output.missing.includes('evidence'), 'missing should include evidence');
  });
```

After all changes, run `npm test` to confirm all tests pass (expect 159+ tests, up from 155).
  </action>
  <verify>
Run: `npm test`
All tests pass. Specifically verify:
- "invalid critical signal without evidence" still asserts valid: false (now with lifecycle_state)
- "backward compat: critical signal without lifecycle_state downgrades evidence to warning" asserts valid: true
- "new critical signal with lifecycle_state but no evidence fails" asserts valid: false
- "new critical signal with empty evidence object fails" asserts valid: false
- "backward compat mode does NOT apply when lifecycle_state is present" asserts valid: false
- All other signal tests unchanged and passing
  </verify>
  <done>
11 signal validation tests (7 original + 4 new) all pass. Backward compatibility verified: pre-existing critical signals get warnings, new critical signals get hard failures, empty evidence is caught, and the Phase 33 constraint is documented in test form. Test count is 159+.
  </done>
</task>

<task type="auto">
  <name>Task 3: Document backward_compat validation behavior in knowledge-store.md</name>
  <files>agents/knowledge-store.md</files>
  <action>
Edit `agents/knowledge-store.md` (NOT `.claude/agents/` -- per CLAUDE.md dual-directory rule).

**Update Section 4.2 "Existing signals (backward compatibility)" paragraph (line ~195)**

Expand the existing backward compatibility paragraph to document the validation behavior:

Replace the existing paragraph:
```
**Existing signals (backward compatibility):** The 46 existing signals have no `lifecycle_state` field. When absent, `lifecycle_state` defaults to `detected`. Bulk triage of existing signals is deferred to Phase 33 (Enhanced Reflector). Schema validation is opt-in -- agents call `frontmatter validate --schema signal` only on NEW signals they create.
```

With:
```
**Existing signals (backward compatibility):** The 46 existing signals have no `lifecycle_state` field. When absent, `lifecycle_state` defaults to `detected`. Bulk triage of existing signals is deferred to Phase 33 (Enhanced Reflector). Schema validation is opt-in -- agents call `frontmatter validate --schema signal` only on NEW signals they create.

**Backward-compat validation (`backward_compat` in FRONTMATTER_SCHEMAS):** When `lifecycle_state` is absent from a signal, `cmdFrontmatterValidate` downgrades conditional `require` fields to warnings (prefixed `backward_compat:`). This allows the 6 pre-existing critical signals (which lack `evidence`) to pass validation. Signals created from the Phase 31+ template always include `lifecycle_state: detected` and receive full strict enforcement.

**Phase 33 triage constraint:** When bulk triage adds `lifecycle_state` to existing critical signals, it MUST also add `evidence` (with at least one `supporting` entry) or downgrade `severity`. Once `lifecycle_state` is present, the backward-compat exemption no longer applies and the conditional evidence requirement becomes a hard failure.
```
  </action>
  <verify>
Grep for "backward_compat" in agents/knowledge-store.md -- should return matches.
Grep for "Phase 33 triage constraint" -- should return match.
Verify the surrounding content (Section 4.2 context) is preserved.
  </verify>
  <done>
knowledge-store.md Section 4.2 documents the backward_compat validation behavior, the lifecycle_state indicator mechanism, and the Phase 33 triage constraint that must be honored when adding lifecycle_state to existing critical signals.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update FORK-DIVERGENCES.md with backward_compat note</name>
  <files>.planning/FORK-DIVERGENCES.md</files>
  <action>
Update `.planning/FORK-DIVERGENCES.md` -- the Runtime section's gsd-tools.js entry (line ~61).

Replace the current "What Changed" description:

```
| `get-shit-done/bin/gsd-tools.js` | Added `signal` key to FRONTMATTER_SCHEMAS with required/conditional/recommended tiered validation; extended `cmdFrontmatterValidate` with conditional requirement and recommended field support | Signal schema enforcement (Phase 31) | keep-fork -- upstream has no signal schema | LOW (additive -- new schema entry and extended function, no upstream overlap) |
```

With:

```
| `get-shit-done/bin/gsd-tools.js` | Added `signal` key to FRONTMATTER_SCHEMAS with required/conditional/recommended tiered validation; extended `cmdFrontmatterValidate` with conditional requirement, recommended field, backward_compat (lifecycle_state indicator), and evidence content validation | Signal schema enforcement (Phase 31) | keep-fork -- upstream has no signal schema | LOW (additive -- new schema entry and extended function, no upstream overlap) |
```
  </action>
  <verify>
Grep for "backward_compat" in .planning/FORK-DIVERGENCES.md -- should return match.
  </verify>
  <done>
FORK-DIVERGENCES.md gsd-tools.js entry updated to reflect the backward_compat and evidence content validation additions alongside the original signal schema divergence.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes with all 159+ tests
2. Run validation against one of the 6 affected real signals:
   `node get-shit-done/bin/gsd-tools.js frontmatter validate ~/.gsd/knowledge/signals/get-shit-done-reflect/2026-02-11-kb-data-loss-migration-gap.md --schema signal`
   Expected: `valid: true`, warnings include `backward_compat: evidence`
3. Run validation against a new critical signal WITH lifecycle_state but WITHOUT evidence:
   Expected: `valid: false`, missing includes `evidence`
4. Run validation against a new critical signal WITH lifecycle_state and empty evidence:
   Expected: `valid: false`, missing includes `evidence (empty)`
5. Run validation against all 6 affected signals and confirm all return valid: true
6. Grep for "backward_compat" in agents/knowledge-store.md -- confirms documentation
7. Grep for "Phase 33 triage constraint" in agents/knowledge-store.md -- confirms constraint documented
8. Grep for "backward_compat" in .planning/FORK-DIVERGENCES.md -- confirms divergence updated
</verification>

<success_criteria>
- All 6 previously failing critical signals now pass validation with backward_compat warnings
- New critical signals still require evidence (hard fail without it)
- New critical signals with empty evidence objects also fail (epistemic rigor enforced)
- Phase 33 constraint documented in code comment, knowledge-store.md, and test form
- All 159+ tests pass including 4 new tests
- No regressions in plan/summary/verification schema validation
- knowledge-store.md documents backward_compat validation behavior
- FORK-DIVERGENCES.md updated with backward_compat note
</success_criteria>

<output>
After completion, create `.planning/phases/31-signal-schema-foundation/31-04-SUMMARY.md`
</output>
