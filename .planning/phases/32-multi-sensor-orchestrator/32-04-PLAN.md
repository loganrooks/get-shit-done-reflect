---
phase: 32-multi-sensor-orchestrator
plan: 04
type: execute
wave: 2
depends_on: ["32-01", "32-02", "32-03"]
files_modified:
  - get-shit-done/workflows/collect-signals.md
  - commands/gsd/collect-signals.md
autonomous: true

must_haves:
  truths:
    - "Running /gsd:collect-signals spawns artifact and git sensors in parallel, then passes their output to the synthesizer"
    - "The orchestrator reads sensor config from the feature manifest to determine which sensors to spawn"
    - "Sensors run via Task() with run_in_background=true for parallel execution"
    - "The synthesizer receives merged JSON from all sensors and is spawned after sensors complete"
    - "The collect-signals command delegates to the refactored workflow"
    - "New agent files are installed to .claude/ via installer"
  artifacts:
    - path: "get-shit-done/workflows/collect-signals.md"
      provides: "Multi-sensor orchestrator workflow with parallel Task() spawning"
      contains: "run_in_background"
      min_lines: 80
    - path: "commands/gsd/collect-signals.md"
      provides: "Updated command entry point"
      contains: "collect-signals"
  key_links:
    - from: "get-shit-done/workflows/collect-signals.md"
      to: "agents/gsd-artifact-sensor.md"
      via: "Task() spawn with subagent_type"
      pattern: "gsd-artifact-sensor"
    - from: "get-shit-done/workflows/collect-signals.md"
      to: "agents/gsd-git-sensor.md"
      via: "Task() spawn with subagent_type"
      pattern: "gsd-git-sensor"
    - from: "get-shit-done/workflows/collect-signals.md"
      to: "agents/gsd-signal-synthesizer.md"
      via: "Task() spawn with sensor outputs"
      pattern: "gsd-signal-synthesizer"
    - from: "get-shit-done/workflows/collect-signals.md"
      to: "get-shit-done/feature-manifest.json"
      via: "sensor config reading"
      pattern: "signal_collection"
---

<objective>
Refactor the collect-signals workflow from a single-agent pattern to a multi-sensor orchestrator that spawns sensors in parallel, collects their JSON outputs, and passes them to the synthesizer. Update the command entry point and sync all new agent files to .claude/ via the installer.

Purpose: This is the integration plan that wires together the sensor agents (Plans 01-03) into the orchestrator workflow. It transforms the user-facing `/gsd:collect-signals` command from spawning one agent to coordinating three sensors and a synthesizer, following the proven map-codebase parallel Task() pattern.
Output: Refactored workflow, updated command, and installed agent files in .claude/.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary-standard.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-multi-sensor-orchestrator/32-RESEARCH.md
@.planning/phases/32-multi-sensor-orchestrator/32-01-SUMMARY.md
@.planning/phases/32-multi-sensor-orchestrator/32-02-SUMMARY.md
@.planning/phases/32-multi-sensor-orchestrator/32-03-SUMMARY.md
@get-shit-done/workflows/collect-signals.md
@get-shit-done/workflows/map-codebase.md
@commands/gsd/collect-signals.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor collect-signals workflow to multi-sensor orchestrator</name>
  <files>get-shit-done/workflows/collect-signals.md</files>
  <action>
Rewrite `get-shit-done/workflows/collect-signals.md` to follow the parallel Task() orchestrator pattern from `map-codebase.md`.

**Keep existing steps:** validate_input, locate_artifacts, check_prerequisites, load_config -- these remain mostly unchanged.

**Replace spawn_signal_collector step with a multi-step orchestration:**

**New Step: load_sensor_config**

Read sensor configuration from the feature manifest or project config:
```bash
# Read sensor config -- check project config first, fall back to manifest defaults
SENSOR_CONFIG=$(cat .planning/config.json 2>/dev/null | node -e "
  const c = JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));
  const sc = c.signal_collection || {};
  const sensors = sc.sensors || {
    artifact: { enabled: true, model: 'auto' },
    git: { enabled: true, model: 'auto' },
    log: { enabled: false, model: 'auto' }
  };
  console.log(JSON.stringify(sensors));
" 2>/dev/null || echo '{"artifact":{"enabled":true,"model":"auto"},"git":{"enabled":true,"model":"auto"},"log":{"enabled":false,"model":"auto"}}')
```

Determine model for each sensor based on `model` field:
- `"auto"`: Use the orchestrator's model_profile to select (quality = opus, balanced = sonnet)
- Specific model string: Use that model

Store enabled sensor list for spawning.

**New Step: spawn_sensors**

For each ENABLED sensor, spawn a Task() with `run_in_background=true`:

**Artifact Sensor** (if enabled):
```
Task(
  subagent_type="gsd-artifact-sensor",
  model="{sensor_model}",
  run_in_background=true,
  description="Collect artifact signals for phase {PADDED_PHASE}",
  prompt="Analyze phase {PADDED_PHASE} execution artifacts.
    Phase directory: {PHASE_DIR}
    Project name: {PROJECT_NAME}
    Model profile: {MODEL_PROFILE}

    Read PLAN.md and SUMMARY.md files from the phase directory.
    Read VERIFICATION.md if it exists.
    Read .planning/config.json for model_profile.
    Apply signal-detection.md rules.
    Return your results as a JSON object with format:
    { sensor: 'artifact', phase: N, signals: [...] }
    Each signal needs: summary, signal_type, signal_category, severity, tags, evidence, confidence, confidence_basis, context."
)
```

Note: DO NOT read artifact contents into variables and pass them in the prompt (the old pattern). Instead, pass FILE PATHS and let the sensor read them itself. This prevents orchestrator context bloat (Research Pitfall 2). The sensor has Read/Bash/Glob/Grep tools.

**Git Sensor** (if enabled):
```
Task(
  subagent_type="gsd-git-sensor",
  model="{sensor_model}",
  run_in_background=true,
  description="Collect git signals for phase {PADDED_PHASE}",
  prompt="Analyze git history for phase {PADDED_PHASE} patterns.
    Phase directory: {PHASE_DIR}
    Project name: {PROJECT_NAME}

    Detect fix-fix-fix chains, file churn, and scope creep.
    Return your results as a JSON object with format:
    { sensor: 'git', phase: N, signals: [...] }"
)
```

**Log Sensor** (if enabled -- disabled by default):
```
Task(
  subagent_type="gsd-log-sensor",
  model="{sensor_model}",
  run_in_background=true,
  description="Collect log signals for phase {PADDED_PHASE}",
  prompt="Phase {PADDED_PHASE}. Return empty results.
    { sensor: 'log', phase: N, signals: [] }"
)
```

**New Step: collect_sensor_outputs**

Wait for all background tasks to complete. Parse each sensor's output to extract the JSON signal candidates. If a sensor failed, log the failure and continue with successful sensor outputs. Collect all sensor JSON arrays into a merged list.

Track: `TOTAL_CANDIDATES`, `SENSORS_COMPLETED`, `SENSORS_FAILED`.

**New Step: spawn_synthesizer**

Spawn the synthesizer as a foreground Task() (NOT background -- we need its report):

```
Task(
  subagent_type="gsd-signal-synthesizer",
  model="{synthesizer_model}",
  description="Synthesize signals for phase {PADDED_PHASE}",
  prompt="Synthesize and persist signals for phase {PADDED_PHASE}.
    Project name: {PROJECT_NAME}

    Raw signal candidates from sensors:
    {MERGED_SENSOR_JSON}

    Read the KB index at ~/.gsd/knowledge/index.md for dedup checking.
    Apply all quality gates: trace filter, cross-sensor dedup, KB dedup, rigor enforcement, per-phase cap.
    Write qualifying signals to ~/.gsd/knowledge/signals/{PROJECT_NAME}/.
    Rebuild index with: bash ~/.gsd/bin/kb-rebuild-index.sh
    Return your Synthesizer Report when complete."
)
```

The synthesizer model follows the `synthesizer_model` config field (default `"auto"`, resolved same as sensor models).

**Keep existing steps:** receive_report (now from synthesizer), present_results (update format for multi-sensor output), commit_signals.

**Update present_results** to show per-sensor breakdowns:

```
GSD > SIGNAL COLLECTION COMPLETE

Phase {X}: {Name}
Plans analyzed: {N}
Sensors run: {artifact, git} (log: disabled)

### Per-Sensor Results
| Sensor | Candidates | Merged | Written |
|--------|------------|--------|---------|
| artifact | N | N | N |
| git | N | N | N |

### Synthesizer Summary
{synthesizer report content}
```

**Update error_handling:** Add sensor failure handling -- if one sensor fails, others still proceed. Only fail the whole workflow if ALL sensors fail or the synthesizer fails.

**Remove:** The old `spawn_signal_collector` step and the inline artifact content reading (replaced by sensors reading files themselves per Research Pitfall 1/2).

**Important architectural notes to include as comments in the workflow:**
- "Sensors return JSON to orchestrator -- they do NOT write to KB (single-writer principle)"
- "Sensor model selection: auto = derive from model_profile; explicit = use specified model"
- "The orchestrator passes file PATHS to sensors, not file CONTENTS (prevents context bloat)"
  </action>
  <verify>
```bash
# File exists with substantial content
wc -l get-shit-done/workflows/collect-signals.md
# Should be >80 lines

# References all three sensor agents
grep -c "gsd-artifact-sensor" get-shit-done/workflows/collect-signals.md
grep -c "gsd-git-sensor" get-shit-done/workflows/collect-signals.md
grep -c "gsd-signal-synthesizer" get-shit-done/workflows/collect-signals.md
# Each >= 1

# Uses parallel Task() pattern
grep -c "run_in_background" get-shit-done/workflows/collect-signals.md
# Should be >= 2 (artifact + git sensors)

# Reads sensor config
grep -c "signal_collection\|sensor.*config\|sensors" get-shit-done/workflows/collect-signals.md
# >= 1

# Does NOT pass artifact contents in prompt (anti-pattern from Research Pitfall 2)
grep -c "PLAN_CONTENT\|SUMMARY_CONTENT\|VERIFICATION_CONTENT" get-shit-done/workflows/collect-signals.md
# Should be 0 -- sensors read files themselves
```
  </verify>
  <done>
Collect-signals workflow refactored from single-agent to multi-sensor orchestrator. Spawns enabled sensors in parallel via Task() with run_in_background, collects JSON outputs, passes to synthesizer for quality gating and KB writes. Reads sensor config from feature manifest. Passes file paths (not contents) to sensors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update command entry point and run installer sync</name>
  <files>commands/gsd/collect-signals.md</files>
  <action>
**Update `commands/gsd/collect-signals.md`:**

The command file needs minimal changes since it delegates to the workflow. Update:

1. Description: Change to "Analyze execution artifacts for a phase using parallel sensors (artifact, git) and synthesize signals into the knowledge base"
2. The `<process>` section: Update step 2 to mention the multi-sensor architecture:
   "Delegate to workflow at `get-shit-done/workflows/collect-signals.md` -- workflow reads sensor config, spawns enabled sensors in parallel (artifact sensor, git sensor), collects their output, and passes to the signal synthesizer for deduplication, rigor enforcement, and KB persistence"
3. Keep allowed-tools list -- ensure `Task` is included (required for sensor/synthesizer spawning)

**Run installer to sync new agent files to .claude/:**

```bash
node bin/install.js --local
```

This copies the new agent files from `agents/` to `.claude/agents/`:
- `agents/gsd-artifact-sensor.md` -> `.claude/agents/gsd-artifact-sensor.md`
- `agents/gsd-git-sensor.md` -> `.claude/agents/gsd-git-sensor.md`
- `agents/gsd-signal-synthesizer.md` -> `.claude/agents/gsd-signal-synthesizer.md`
- `agents/gsd-log-sensor.md` -> `.claude/agents/gsd-log-sensor.md`
- Updated `agents/gsd-signal-collector.md` -> `.claude/agents/gsd-signal-collector.md`
- Updated `get-shit-done/workflows/collect-signals.md` -> `.claude/get-shit-done/workflows/collect-signals.md`
- Updated `get-shit-done/feature-manifest.json` -> `.claude/get-shit-done/feature-manifest.json`
- Updated `commands/gsd/collect-signals.md` -> `.claude/commands/gsd/collect-signals.md`

The installer's `replacePathsInContent()` converts `~/` path prefixes to `./` for local install context. Verify this conversion happened correctly for the new agent files.

**Verify installation:**
```bash
# Check all new agent files are installed
ls -la .claude/agents/gsd-artifact-sensor.md
ls -la .claude/agents/gsd-git-sensor.md
ls -la .claude/agents/gsd-signal-synthesizer.md
ls -la .claude/agents/gsd-log-sensor.md

# Verify path conversion (should use ./ not ~/)
grep '~/\.' .claude/agents/gsd-artifact-sensor.md | head -3
# Should be empty -- all paths should use ./ prefix

# Verify workflow is installed
ls -la .claude/get-shit-done/workflows/collect-signals.md

# Verify feature manifest is installed
node -e "const m = require('./.claude/get-shit-done/feature-manifest.json'); console.log('Installed features:', Object.keys(m.features).length)"
# Should show 5

# Run tests to confirm nothing broken
npm test
```
  </action>
  <verify>
```bash
# Command file updated
grep -c "parallel\|multi-sensor\|synthesize" commands/gsd/collect-signals.md
# >= 1

# All agent files installed in .claude/
test -f .claude/agents/gsd-artifact-sensor.md && echo "artifact sensor installed"
test -f .claude/agents/gsd-git-sensor.md && echo "git sensor installed"
test -f .claude/agents/gsd-signal-synthesizer.md && echo "synthesizer installed"
test -f .claude/agents/gsd-log-sensor.md && echo "log sensor installed"

# Path conversion verified (no ~/ paths in installed files)
grep -r '~/\.' .claude/agents/gsd-artifact-sensor.md .claude/agents/gsd-git-sensor.md .claude/agents/gsd-signal-synthesizer.md .claude/agents/gsd-log-sensor.md 2>/dev/null | grep -v '#' | head -5
# Should be empty or only in comments

# All tests pass
npm test
```
  </verify>
  <done>
Command entry point updated for multi-sensor architecture. All new agent files (artifact sensor, git sensor, signal synthesizer, log sensor), updated workflow, feature manifest, and command file installed to .claude/ via installer with correct path prefix conversion. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `get-shit-done/workflows/collect-signals.md` spawns sensors in parallel via Task()
2. `get-shit-done/workflows/collect-signals.md` reads sensor config from feature manifest
3. `get-shit-done/workflows/collect-signals.md` passes sensor output to synthesizer
4. `commands/gsd/collect-signals.md` updated for multi-sensor description
5. All 4 new agent files installed in `.claude/agents/`
6. Updated workflow and manifest installed in `.claude/`
7. Path prefix conversion (`~/` to `./`) verified in installed files
8. `npm test` passes
</verification>

<success_criteria>
The complete multi-sensor orchestrator is assembled and installed. Running `/gsd:collect-signals {phase}` will spawn enabled sensors in parallel, collect their structured JSON output, and pass it to the synthesizer for quality-gated KB persistence. The full data flow from command to sensors to synthesizer to KB is wired end-to-end.
</success_criteria>

<output>
After completion, create `.planning/phases/32-multi-sensor-orchestrator/32-04-SUMMARY.md`
</output>
