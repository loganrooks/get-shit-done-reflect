# Continue Here: Post-v1.15 Brainstorming & v1.16 Scoping

**Paused:** 2026-02-25
**Context:** Post-v1.15 release. Extended brainstorming session produced two milestone candidates at different maturity levels. Patch v1.15.1 (reflect command) may or may not be done yet — check VERSION file.
**Resume with:** `/gsd:resume-work` — then proceed to `/gsd:new-milestone` for v1.16 (signal lifecycle).

## Status

- v1.15.0 released and installed (both local + global)
- v1.15.1 patch: restore `/gsd:reflect` command (pending or done — check)
- Local patches cleaned up (false positive from dogfooding — see `sig-2026-02-24-local-patches-false-positive-dogfooding`)
- Backlog system exists as CLI plumbing but lacks a slash command and isn't suited for rich ideation

---

## MILESTONE CANDIDATE A: Signal Lifecycle & Reflection (v1.16 — READY TO SCOPE)

**Maturity:** High. Architecture discussed in depth. Ready for `/gsd:new-milestone`.

### Core Thesis

The self-improvement cycle has 6 stages. We only have stage 1 partially implemented. The rest doesn't exist.

```
DETECT ──→ TRIAGE ──→ REMEDIATE ──→ VERIFY ──→ RECURRENCE CHECK ──→ LESSON
  ✅          ❌          ❌           ❌            ❌                  ❌
(partial)
```

### A1. Expand collect-signals into a multi-sensor orchestrator

**Current state:** collect-signals only reads PLAN.md vs SUMMARY.md diffs.

**Target architecture:**
```
/gsd:collect-signals (orchestrator)
  ├── artifact-sensor     (PLAN vs SUMMARY, VERIFICATION — what exists today)
  ├── git-sensor          (commit patterns, churn, scope creep, "fix fix fix" patterns)
  ├── log-sensor          (conversation patterns, interruptions, undetected issues)
  ├── metrics-sensor      (token usage, session counts — when available)
  ├── ...future sensors
  └── signal-synthesizer  (dedup, merge, cross-sensor correlation)
```

**Key design decisions:**
- One command, multiple agents (same pattern as `/gsd:map-codebase`)
- Each sensor emits raw signals; orchestrator merges and deduplicates
- Extensible: adding token tracking later = adding a metrics-sensor agent + detection rule
- Log analysis IS a collect-signals task (not separate) — undetected issues in logs are signals
- Sensors should have configurable model assignments via settings:
  ```json
  {
    "signal_collection": {
      "sensors": {
        "artifact": { "enabled": true, "model": "auto" },
        "git": { "enabled": true, "model": "haiku" },
        "log": { "enabled": true, "model": "auto" },
        "metrics": { "enabled": false }
      }
    }
  }
  ```

**Open question:** Where does Claude Code store session logs? Needs investigation (spike candidate).

### A2. Signal lifecycle metadata

**Problem:** Signals are write-once dead letters. Need lifecycle tracking.

**Proposed schema extensions:**
```yaml
# Source tracing (enhanced from current source: auto|manual)
source:
  sensor: artifact | git | log | metrics | manual
  evidence: ["specific lines/data that triggered detection"]

# Triage (NEW)
triage:
  decision: address | defer | dismiss | investigate | needs-data
  rationale: "3rd recurrence of installer issue"
  by: human | reflect
  at: ISO-8601

# Remediation tracking (NEW)
remediation:
  ref: { milestone: v1.16, phase: 31, plan: 2, commit: abc123 }
  approach: "why this fix, not just what"
  expected_outcome: "what success looks like"
  status: planned | in-progress | completed | failed

# Verification (NEW)
verification:
  status: pending | confirmed | failed | inconclusive
  method: manual | automated | absence-of-recurrence
  at: ISO-8601

# Recurrence (NEW)
recurrence_of: sig-id-of-original
previous_remediations: [sig-id → what was tried]
```

**Key decision:** Signal immutability must be relaxed. Detection data stays frozen, but lifecycle fields (triage, remediation, verification) are mutable. This is necessary for the cycle to close.

**Integration with plans:** Plans should declare `resolves_signals: [sig-id-1, sig-id-2]` in frontmatter. When a plan executes, the referenced signals' remediation fields update automatically.

### A3. Prediction mechanism

**Idea:** Before execution, the system predicts expected outcomes (token range, likely deviations, risk areas). After execution, compare predictions to actuals. The delta is itself a signal source.

**Applications:**
- Predicted token budget for a phase vs actual → efficiency signal
- Predicted risk areas vs where deviations actually occurred → planning quality signal
- Predicted vs actual duration for quick fixes → complexity estimation quality

**This creates a new deviation detection surface** — not just "plan vs execution" but "prediction vs reality." Could be integrated into plan-phase output (planner predicts) and collect-signals input (sensors compare).

### A4. Build /gsd:reflect

**Purpose:** Synthesis layer. Reads accumulated signals, clusters by theme, identifies patterns, extracts lessons, triages unresolved signals.

**What reflect does that collect-signals doesn't:**
- collect-signals = "what happened" (per-phase, mechanical, sensor-driven)
- reflect = "what does it mean" (cross-phase, cross-milestone, interpretive)

**Key responsibilities:**
1. Read all active signals for the project
2. Cluster by theme (installer issues, agent spec drift, TDD correlation, etc.)
3. Identify recurring patterns (8 installer signals across 3 milestones = systemic issue)
4. Triage untriaged signals (propose decisions for user approval)
5. Check remediation outcomes (did previous fixes work? trace recurrences)
6. Extract lessons from completed cycles (signal → remediation → verified → lesson)
7. Identify positive patterns too (what works well → recommend more of it)
8. Produce candidate themes for next milestone (forward-looking output)

**When to run:**
- On-demand anytime
- Prompted by `/gsd:complete-milestone` ("want to reflect before moving on?")
- Could be part of a pre-milestone deliberation step

**Output:** REFLECTION.md artifact + updated lesson entries in KB + triage decisions on signals

### A5. Verification as passive check inside collect-signals

**Key insight:** Verification doesn't need its own command. When sensors run after a phase, they also check: "is this new signal a recurrence of a previously-remediated one?" If yes → old signal's verification status = `failed`, new signal links back. If no recurrence in the relevant area → evidence toward `confirmed`.

### Implicit concerns to address in this milestone

1. **Blind spot detection:** If user manually creates a signal for something collect-signals missed → meta-signal about sensor gaps
2. **Symptomatic vs systemic:** Reflect must identify shared root causes across multiple signals, not just treat them individually
3. **Positive feedback loops:** System is biased toward problems. TDD discipline signal shows what works — reflect should amplify this
4. **Proportionality:** Reflection shouldn't consume disproportionate tokens. Lightweight by default, deep-dive on-demand
5. **Lessons pipeline is broken:** 44 signals, 1 lesson, 4 milestones. Reflect is the fix
6. **Remediation quality:** "Was it addressed?" vs "Was it addressed well?" — recurrence is the test but it's lagging. Reflect should assess proactively

---

## MILESTONE CANDIDATE B: Workflow Intelligence & System Maturity (v1.17+ — NEEDS MORE BRAINSTORMING)

**Maturity:** Low-medium. Ideas discussed but not architecturally resolved. Needs more deliberation, possibly spikes.

### B1. Workflow Introspection & Adaptive Customization

**Problem:** The system can't observe how the user actually uses it.

**Two components:**
1. **Observation** — analyze interaction patterns (interruptions, command frequency, what gets skipped)
2. **Prescription with pushback** — not blind encoding of habits. Good habits → automate. Bad habits → push back with reasoning.

**The "patches" metaphor:** User-specific overlays on `.claude/` files. Runtime customizations for a given user, distinct from GSD development.

**Critical constraint:** System should have opinions. "You skip verification — I'd recommend keeping it" alongside "You use /gsd:quick for small tasks — that's efficient, let's optimize it."

**Open questions (unresolved):**
- Where does interaction data come from? Claude Code chat history accessibility?
- Hook-based logging vs in-session observation?
- Storage format for user workflow profiles?
- How to distinguish good habits from bad ones programmatically?

### B2. Token/Metrics Tracking

**Problem:** No token usage tracking exists. Only context window % in statusline.

**Ideas:**
- Track per phase, per plan, per command, and BETWEEN phases
- Use token patterns as signals: "phase X burned 3x tokens of phase Y"
- Detect usage outside designed workflows → signal for unstructured work

**Needs spike:** What does Claude Code expose in hook payloads? Session logs? API usage data?

### B3. Deliberation System / Pre-Milestone Thinking Phase

**Problem:** `/gsd:new-milestone` rushes forward. No supported mode for "I have half-formed ideas and need to think."

**Ideas:**
- `.planning/candidates/` directory for milestone candidates at different maturity levels
- Each candidate has brainstorming context, open questions, maturity rating
- `/gsd:new-milestone` reads candidates alongside backlog items when scoping
- Deliberation as a formal phase between milestones

**Relationship to reflect:** Reflection is backward-looking (what happened, what it means). Deliberation is forward-looking (what should we build). But reflection feeds deliberation — they're complementary, not separate.

### B4. Backlog System Improvements

**Problem:** Backlog exists as CLI plumbing but:
- No `/gsd:backlog` slash command
- Schema too flat for rich ideas
- Not suited for brainstorming with context and open questions

**What's needed:** Something between "raw backlog item" and "full milestone requirement."

### B5. Testing & QA Improvements

**Problem:** 256 tests pass but:
- Smoke tests manual-trigger only, require API key
- No manual testing playbook for release verification
- Update flow exposed patches issue — should have been caught

### B6. Roadmap Parallelization

**Idea:** Not everything in a roadmap needs to be sequential. Some phases could run in parallel using worktrees or branches.

**Needs research:** What does Claude Code (Feb 2026) recommend for parallel workstreams? Worktrees? Multiple sessions? What are the constraints?

**Integration:** The roadmapper could identify parallelizable phases and mark them. Execute-phase could leverage worktrees for independent work.

---

## Architecture Summary: Agent/Command Mapping

| Stage | Command | Agent(s) | When |
|-------|---------|----------|------|
| Detect | `/gsd:collect-signals` | artifact-sensor, git-sensor, log-sensor, metrics-sensor | After each phase |
| Triage + Synthesize | `/gsd:reflect` | reflect-agent | After milestone or on-demand |
| Remediate | `/gsd:plan-phase` | planner (declares `resolves_signals`) | During milestone execution |
| Verify | built into collect-signals | recurrence-checker | Passive, each phase |
| Lesson | output of reflect | reflect-agent | After verification confirms |

---

## Immediate Actions

1. ~~Quick patch (v1.15.1): Restore `/gsd:reflect` command~~ (check if done)
2. Run `/gsd:new-milestone` for v1.16 using Candidate A above as input
3. Candidate B stays here for post-v1.16 deliberation

## Meta-Observations

- The system lacks a native "brainstorming" or "deliberation" mode. This .continue-here.md is a workaround.
- The backlog system can't hold rich, contextual ideas. It's structured for items, not discussions.
- GSD supports one active milestone. There's no concept of milestone candidates at different maturity levels.
- These meta-observations are themselves candidates for Milestone B.
