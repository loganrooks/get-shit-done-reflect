# Continue Here: Quick Task 7 — Dual-Install Detection (Phase 1)

**Paused:** 2026-02-25
**Context:** Quick task 7 planned but not yet executed. Plan revised to 3 tasks (from original 5) after design deliberation split the work into Phase 1 (detection/awareness) and Phase 2 (update flow/hooks).

<current_state>
Quick task 7 has a finalized PLAN at `.planning/quick/7-implement-dual-installation-detection-an/7-PLAN.md` with 3 tasks ready to execute. No code has been written yet — this session was planning and design deliberation only.
</current_state>

<completed_work>

- Explored the full dual-install codebase: gsd-tools.js init path resolution, installer --local/--global handling, hook detection logic, command file format, update workflow
- Designed the intended topology: global = baseline, local = version pin (npm model)
- Resolved key design questions: precedence rules, cross-project impact, autocomplete behavior
- Split work into Phase 1 (detection/awareness) and Phase 2 (update flow/hooks/suppression)
- Created and committed revised 7-PLAN.md with 3 tasks
- Updated the existing dual-install todo to capture Phase 2 design decisions (committed as `4815604`)
- Created `.planning/quick/7-implement-dual-installation-detection-an/` directory
</completed_work>

<remaining_work>

**Phase 1 (Quick Task 7 — ready to execute):**
- Task 1: Add `detectDualInstall(cwd)` helper to gsd-tools.js, call from all 4 init commands
- Task 2: Add cross-scope warning to installer + `injectVersionScope()` for command descriptions
- Task 3: Surface dual-install on resume workflow + create `references/dual-installation.md`
- After execution: commit, bump to v1.15.2, release

**Phase 2 (deferred — see todo):**
- Update workflow with scope choice (Local/Global/Both)
- Per-scope changelog deliberation with different framing for local vs global blast radius
- Hook awareness: scope-aware indicators (⬆ local, ⬆ global, ⬆ both)
- Version-pinned suppression: store `declined_global_version: "1.16.0"`, auto-expires on new release
</remaining_work>

<decisions_made>

- **Topology model**: Global = baseline (available everywhere), Local = version pin (overrides global). Mirrors npm global vs local packages. Dual install is supported and informed, not discouraged.
- **Phase split**: Detection/awareness is a patch (v1.15.2). Update flow/hooks need more design and are deferred.
- **No "Skip" in update flow**: If user runs /gsd:update they want to update something. Ctrl+c to cancel.
- **Version-pinned suppression over boolean**: Store the specific declined version, not just a flag. Auto-expires when a newer version appears on npm. No timers or cleanup needed.
- **Scope-aware indicators over dimming**: Statusline should show WHICH scope is outdated (⬆ local, ⬆ global) rather than just dimming a generic indicator.
- **Per-scope changelog deliberation**: Local update framed as "this project only", global framed as "ALL projects without local installs". Different blast radius = different review framing.
- **Command description injection**: Installer appends `(v1.15.2 local)` or `(v1.15.2 global)` to command `description:` field in YAML frontmatter — shows in autocomplete to differentiate dual installs.
</decisions_made>

<blockers>
None. Plan is ready to execute.
</blockers>

<context>
This started as a todo review ("Design dual-installation update strategy") that evolved into a deep design session. The user experiences real friction from dual installs: duplicate autocomplete entries, confusion about which install is active, silent version drift during updates. We explored the codebase thoroughly (gsd-tools.js path resolution, installer flags, hook scripts, command file format) before designing the solution. The user pushed back productively on several assumptions — the autocomplete issue may have remedies beyond "just don't install both", suppression needs to be smart (version-pinned, not permanent), and changelog review should differ by scope. The Phase 2 todo at `.planning/todos/pending/2026-02-25-design-dual-installation-update-strategy-for-split-local-global-installs.md` captures all resolved and open design decisions.
</context>

<next_action>
Execute quick task 7 Phase 1. Clear context first, then run execute-phase or manually execute the 3 tasks in the plan at `.planning/quick/7-implement-dual-installation-detection-an/7-PLAN.md`. After execution: run tests, commit, bump version to v1.15.2, release. Then optionally proceed to Phase 2 or start v1.16 milestone (Signal Lifecycle & Reflection).
</next_action>
